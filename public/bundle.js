(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
module.exports={
  "nodes": [
    {
      "id": "fepi6iab718",
      "group": "input",
      "x": 10,
      "y": 10,
      "bias": 0,
      "sumofw": 0,
      "actMethod": "identity",
      "actvalue": 0
    },
    {
      "id": "bnhmg8ojmi",
      "group": "input",
      "x": 45,
      "y": 10,
      "bias": 0,
      "sumofw": 0,
      "actMethod": "identity",
      "actvalue": 1
    },
    {
      "id": "a5t2qhljfb",
      "group": "input",
      "x": 80,
      "y": 10,
      "bias": 0,
      "sumofw": 0,
      "actMethod": "identity",
      "actvalue": 1
    },
    {
      "id": "vjzcmo4y5l",
      "group": "input",
      "x": 115,
      "y": 10,
      "bias": 0,
      "sumofw": 0,
      "actMethod": "identity",
      "actvalue": 0
    },
    {
      "id": "i9h9tsiadt",
      "group": "input",
      "x": 150,
      "y": 10,
      "bias": 0,
      "sumofw": 0,
      "actMethod": "identity",
      "actvalue": 0
    },
    {
      "id": "f77px83jht",
      "group": "input",
      "x": 10,
      "y": 45,
      "bias": 0,
      "sumofw": 0,
      "actMethod": "identity",
      "actvalue": 0
    },
    {
      "id": "jgv7zzikoz",
      "group": "input",
      "x": 45,
      "y": 45,
      "bias": 0,
      "sumofw": 0,
      "actMethod": "identity",
      "actvalue": 0
    },
    {
      "id": "imdituj5xjd",
      "group": "input",
      "x": 80,
      "y": 45,
      "bias": 0,
      "sumofw": 0,
      "actMethod": "identity",
      "actvalue": 1
    },
    {
      "id": "asyj3ayjz3",
      "group": "input",
      "x": 115,
      "y": 45,
      "bias": 0,
      "sumofw": 0,
      "actMethod": "identity",
      "actvalue": 1
    },
    {
      "id": "5r7qpsybzm",
      "group": "input",
      "x": 150,
      "y": 45,
      "bias": 0,
      "sumofw": 0,
      "actMethod": "identity",
      "actvalue": 0
    },
    {
      "id": "sovz0h6kg2",
      "group": "input",
      "x": 10,
      "y": 80,
      "bias": 0,
      "sumofw": 0,
      "actMethod": "identity",
      "actvalue": 0
    },
    {
      "id": "rsopcs57xp",
      "group": "input",
      "x": 45,
      "y": 80,
      "bias": 0,
      "sumofw": 0,
      "actMethod": "identity",
      "actvalue": 1
    },
    {
      "id": "365ja83vqlx",
      "group": "input",
      "x": 80,
      "y": 80,
      "bias": 0,
      "sumofw": 0,
      "actMethod": "identity",
      "actvalue": 1
    },
    {
      "id": "xu3zvbajwna",
      "group": "input",
      "x": 115,
      "y": 80,
      "bias": 0,
      "sumofw": 0,
      "actMethod": "identity",
      "actvalue": 0
    },
    {
      "id": "q0xziza31k8",
      "group": "input",
      "x": 150,
      "y": 80,
      "bias": 0,
      "sumofw": 0,
      "actMethod": "identity",
      "actvalue": 0
    },
    {
      "id": "6q2ufizcipi",
      "group": "input",
      "x": 10,
      "y": 115,
      "bias": 0,
      "sumofw": 0,
      "actMethod": "identity",
      "actvalue": 0
    },
    {
      "id": "pvl59v1bpl",
      "group": "input",
      "x": 45,
      "y": 115,
      "bias": 0,
      "sumofw": 0,
      "actMethod": "identity",
      "actvalue": 0
    },
    {
      "id": "mnjavoybnl",
      "group": "input",
      "x": 80,
      "y": 115,
      "bias": 0,
      "sumofw": 0,
      "actMethod": "identity",
      "actvalue": 1
    },
    {
      "id": "jcqx6i2ejd7",
      "group": "input",
      "x": 115,
      "y": 115,
      "bias": 0,
      "sumofw": 0,
      "actMethod": "identity",
      "actvalue": 1
    },
    {
      "id": "qrwq6wrrkdc",
      "group": "input",
      "x": 150,
      "y": 115,
      "bias": 0,
      "sumofw": 0,
      "actMethod": "identity",
      "actvalue": 0
    },
    {
      "id": "cthe1awnh2i",
      "group": "input",
      "x": 10,
      "y": 150,
      "bias": 0,
      "sumofw": 0,
      "actMethod": "identity",
      "actvalue": 0
    },
    {
      "id": "ffrmo49ajan",
      "group": "input",
      "x": 45,
      "y": 150,
      "bias": 0,
      "sumofw": 0,
      "actMethod": "identity",
      "actvalue": 0
    },
    {
      "id": "ahuk95vg76s",
      "group": "input",
      "x": 80,
      "y": 150,
      "bias": 0,
      "sumofw": 0,
      "actMethod": "identity",
      "actvalue": 0
    },
    {
      "id": "qpb0jk3x57",
      "group": "input",
      "x": 115,
      "y": 150,
      "bias": 0,
      "sumofw": 0,
      "actMethod": "identity",
      "actvalue": 1
    },
    {
      "id": "pvdthg12hf",
      "group": "input",
      "x": 150,
      "y": 150,
      "bias": 0,
      "sumofw": 0,
      "actMethod": "identity",
      "actvalue": 0
    },
    {
      "id": "e9m8urvkrcu",
      "group": "1",
      "x": 300,
      "y": 10,
      "bias": 0,
      "sumofw": -0.6881339523460097,
      "actMethod": "identity",
      "actvalue": -0.29086766937615843
    },
    {
      "id": "zkikpdy4lzr",
      "group": "1",
      "x": 335,
      "y": 10,
      "bias": 0,
      "sumofw": -6.922271691484147,
      "actMethod": "identity",
      "actvalue": -6.23531712800823
    },
    {
      "id": "e9j0hw6zjka",
      "group": "1",
      "x": 370,
      "y": 10,
      "bias": 0,
      "sumofw": -10.285367757223131,
      "actMethod": "identity",
      "actvalue": -10.208625793633605
    },
    {
      "id": "48o4q5q22kf",
      "group": "1",
      "x": 405,
      "y": 10,
      "bias": 0,
      "sumofw": -20.05125653513267,
      "actMethod": "identity",
      "actvalue": -19.462032587387075
    },
    {
      "id": "le5qn0l5fo",
      "group": "1",
      "x": 440,
      "y": 10,
      "bias": 0,
      "sumofw": 7.51391695682368,
      "actMethod": "identity",
      "actvalue": 7.528692284786021
    },
    {
      "id": "e5eoamjn9wj",
      "group": "1",
      "x": 300,
      "y": 45,
      "bias": 0,
      "sumofw": 22.304355977348248,
      "actMethod": "identity",
      "actvalue": 22.228056079116733
    },
    {
      "id": "485i3bszn4b",
      "group": "1",
      "x": 335,
      "y": 45,
      "bias": 0,
      "sumofw": 52.60004016636523,
      "actMethod": "identity",
      "actvalue": 52.424702844772526
    },
    {
      "id": "q81oy0fxdx",
      "group": "1",
      "x": 370,
      "y": 45,
      "bias": 0,
      "sumofw": 47.47003710967081,
      "actMethod": "identity",
      "actvalue": 46.48097585828763
    },
    {
      "id": "o2cf5j2mqnb",
      "group": "1",
      "x": 405,
      "y": 45,
      "bias": 0,
      "sumofw": -0.7506407941414253,
      "actMethod": "identity",
      "actvalue": -1.4891899922820642
    },
    {
      "id": "xydml8hbx6i",
      "group": "1",
      "x": 440,
      "y": 45,
      "bias": 0,
      "sumofw": -35.257333938546715,
      "actMethod": "identity",
      "actvalue": -35.23323802904765
    },
    {
      "id": "ouye9washu",
      "group": "1",
      "x": 300,
      "y": 80,
      "bias": 0,
      "sumofw": -7.136407519004052,
      "actMethod": "identity",
      "actvalue": -7.451329698875305
    },
    {
      "id": "4jk8ybzo9m7",
      "group": "1",
      "x": 335,
      "y": 80,
      "bias": 0,
      "sumofw": 41.83540577135125,
      "actMethod": "identity",
      "actvalue": 41.25509797854359
    },
    {
      "id": "ccvxgu45qlf",
      "group": "1",
      "x": 370,
      "y": 80,
      "bias": 0,
      "sumofw": 58.53254628470888,
      "actMethod": "identity",
      "actvalue": 59.20838889220958
    },
    {
      "id": "lcv04zvdygl",
      "group": "1",
      "x": 405,
      "y": 80,
      "bias": 0,
      "sumofw": 114.9916531659716,
      "actMethod": "identity",
      "actvalue": 115.19943896987498
    },
    {
      "id": "d776fr0467h",
      "group": "1",
      "x": 440,
      "y": 80,
      "bias": 0,
      "sumofw": 10.540388763275653,
      "actMethod": "identity",
      "actvalue": 10.569033021327165
    },
    {
      "id": "g4ibepebmt6",
      "group": "1",
      "x": 300,
      "y": 115,
      "bias": 0,
      "sumofw": 11.636180633453735,
      "actMethod": "identity",
      "actvalue": 11.669682511558772
    },
    {
      "id": "v39pxc7w1yo",
      "group": "1",
      "x": 335,
      "y": 115,
      "bias": 0,
      "sumofw": 17.53178693767566,
      "actMethod": "identity",
      "actvalue": 17.963725546905877
    },
    {
      "id": "wosf8yjbujp",
      "group": "1",
      "x": 370,
      "y": 115,
      "bias": 0,
      "sumofw": -5.906250662109727,
      "actMethod": "identity",
      "actvalue": -6.04207302305046
    },
    {
      "id": "g7pablxhbfm",
      "group": "1",
      "x": 405,
      "y": 115,
      "bias": 0,
      "sumofw": -39.334074491679864,
      "actMethod": "identity",
      "actvalue": -39.681647763789904
    },
    {
      "id": "k1thp962qe",
      "group": "1",
      "x": 440,
      "y": 115,
      "bias": 0,
      "sumofw": -64.85030170586202,
      "actMethod": "identity",
      "actvalue": -65.16882785776359
    },
    {
      "id": "yqk0bvuib1",
      "group": "1",
      "x": 300,
      "y": 150,
      "bias": 0,
      "sumofw": 0,
      "actMethod": "identity",
      "actvalue": 0
    },
    {
      "id": "a02nydyxp6n",
      "group": "1",
      "x": 335,
      "y": 150,
      "bias": 0,
      "sumofw": -6.960036954614971,
      "actMethod": "identity",
      "actvalue": -7.187272241816948
    },
    {
      "id": "vh74f1yqsii",
      "group": "1",
      "x": 370,
      "y": 150,
      "bias": 0,
      "sumofw": 3.926861782695436,
      "actMethod": "identity",
      "actvalue": 3.618833119538671
    },
    {
      "id": "yqev545p6ag",
      "group": "1",
      "x": 405,
      "y": 150,
      "bias": 0,
      "sumofw": 19.20668088202713,
      "actMethod": "identity",
      "actvalue": 19.10704592091615
    },
    {
      "id": "ij2lsmyzo1h",
      "group": "1",
      "x": 440,
      "y": 150,
      "bias": 0,
      "sumofw": -68.51637870184082,
      "actMethod": "identity",
      "actvalue": -68.23585531393012
    },
    {
      "id": "4wlce5ldwuo",
      "group": "output",
      "x": 498.8333333333338,
      "y": 10.20833333333374,
      "bias": 0,
      "sumofw": -1530.6368367040216,
      "actMethod": "thresold",
      "actvalue": 0
    },
    {
      "id": "9i84r5pz09",
      "group": "output",
      "x": 538.2083333333339,
      "y": 10.625000000000426,
      "bias": 0,
      "sumofw": -121.6330124935173,
      "actMethod": "thresold",
      "actvalue": 0
    },
    {
      "id": "fuis6jhff0v",
      "group": "output",
      "x": 498.20833333333394,
      "y": 47.29166666666711,
      "bias": 0,
      "sumofw": -3328.225173843658,
      "actMethod": "thresold",
      "actvalue": 0
    },
    {
      "id": "gggfnldg4gv",
      "group": "output",
      "x": 536.5416666666673,
      "y": 46.45833333333377,
      "bias": 0,
      "sumofw": 9556.399364618865,
      "actMethod": "thresold",
      "actvalue": 1
    },
    {
      "id": "mti2qoy08rm",
      "group": "selftrain",
      "x": 470.08333333333366,
      "y": 265.20833333333354,
      "bias": 0,
      "sumofw": 3969.9416778291766,
      "actMethod": "thresold",
      "actvalue": 1
    },
    {
      "id": "yun3svzumda",
      "group": 10,
      "x": -20,
      "y": 10,
      "bias": 0,
      "sumofw": 0,
      "actMethod": "identity",
      "actvalue": 0
    },
    {
      "id": "8qmjxds6vq",
      "group": 10,
      "x": 180,
      "y": 10,
      "bias": 0,
      "sumofw": 0,
      "actMethod": "identity",
      "actvalue": 0
    },
    {
      "id": "d0l9pwlhh58",
      "group": 10,
      "x": -20,
      "y": 45,
      "bias": 0,
      "sumofw": 0,
      "actMethod": "identity",
      "actvalue": 0
    },
    {
      "id": "mt9ajyca4jb",
      "group": 10,
      "x": 180,
      "y": 45,
      "bias": 0,
      "sumofw": 0,
      "actMethod": "identity",
      "actvalue": 0
    },
    {
      "id": "jiy9vgk3p6c",
      "group": 10,
      "x": -20,
      "y": 80,
      "bias": 0,
      "sumofw": 0,
      "actMethod": "identity",
      "actvalue": 0
    },
    {
      "id": "kfce4u3en1j",
      "group": 10,
      "x": 180,
      "y": 80,
      "bias": 0,
      "sumofw": 0,
      "actMethod": "identity",
      "actvalue": 0
    },
    {
      "id": "fhp87509j3w",
      "group": 10,
      "x": -20,
      "y": 115,
      "bias": 0,
      "sumofw": 0,
      "actMethod": "identity",
      "actvalue": 0
    },
    {
      "id": "bhcmhr9mslp",
      "group": 10,
      "x": 180,
      "y": 115,
      "bias": 0,
      "sumofw": 0,
      "actMethod": "identity",
      "actvalue": 0
    },
    {
      "id": "i2gya8prn7s",
      "group": 10,
      "x": -20,
      "y": 150,
      "bias": 0,
      "sumofw": 0,
      "actMethod": "identity",
      "actvalue": 0
    },
    {
      "id": "ubb6v94cv6",
      "group": 10,
      "x": 180,
      "y": 150,
      "bias": 0,
      "sumofw": 0,
      "actMethod": "identity",
      "actvalue": 0
    },
    {
      "id": "tz98ncky8x",
      "group": 10,
      "x": 10,
      "y": -20,
      "bias": 0,
      "sumofw": 0,
      "actMethod": "identity",
      "actvalue": 0
    },
    {
      "id": "frlysobaw8j",
      "group": 10,
      "x": 10,
      "y": 180,
      "bias": 0,
      "sumofw": 0,
      "actMethod": "identity",
      "actvalue": 0
    },
    {
      "id": "dorzctchp2f",
      "group": 10,
      "x": 45,
      "y": -20,
      "bias": 0,
      "sumofw": 0,
      "actMethod": "identity",
      "actvalue": 0
    },
    {
      "id": "nz61iv5fw6p",
      "group": 10,
      "x": 45,
      "y": 180,
      "bias": 0,
      "sumofw": 0,
      "actMethod": "identity",
      "actvalue": 0
    },
    {
      "id": "g2thoplak1c",
      "group": 10,
      "x": 80,
      "y": -20,
      "bias": 0,
      "sumofw": 0,
      "actMethod": "identity",
      "actvalue": 0
    },
    {
      "id": "oso3eprfwum",
      "group": 10,
      "x": 80,
      "y": 180,
      "bias": 0,
      "sumofw": 0,
      "actMethod": "identity",
      "actvalue": 0
    },
    {
      "id": "s4jhju9ioi",
      "group": 10,
      "x": 115,
      "y": -20,
      "bias": 0,
      "sumofw": 0,
      "actMethod": "identity",
      "actvalue": 0
    },
    {
      "id": "gtlcc3bdmmo",
      "group": 10,
      "x": 115,
      "y": 180,
      "bias": 0,
      "sumofw": 0,
      "actMethod": "identity",
      "actvalue": 0
    },
    {
      "id": "81ll0y30qpx",
      "group": 10,
      "x": 150,
      "y": -20,
      "bias": 0,
      "sumofw": 0,
      "actMethod": "identity",
      "actvalue": 0
    },
    {
      "id": "ykrys8i8ejh",
      "group": 10,
      "x": 150,
      "y": 180,
      "bias": 0,
      "sumofw": 0,
      "actMethod": "identity",
      "actvalue": 0
    },
    {
      "id": "gdcdqat97mj",
      "group": 10,
      "x": -20,
      "y": -20,
      "bias": 0,
      "sumofw": 0,
      "actMethod": "identity",
      "actvalue": 0
    },
    {
      "id": "pgazjtga0ab",
      "group": 10,
      "x": 180,
      "y": -20,
      "bias": 0,
      "sumofw": 0,
      "actMethod": "identity",
      "actvalue": 0
    },
    {
      "id": "iiqhub9j9t",
      "group": 10,
      "x": -20,
      "y": 180,
      "bias": 0,
      "sumofw": 0,
      "actMethod": "identity",
      "actvalue": 0
    },
    {
      "id": "p07y3qfyelf",
      "group": 10,
      "x": 180,
      "y": 180,
      "bias": 0,
      "sumofw": 0,
      "actMethod": "identity",
      "actvalue": 0
    }
  ],
  "links": [
    {
      "source": "fepi6iab718",
      "target": "e9m8urvkrcu",
      "value": 33.49959280461803
    },
    {
      "source": "gdcdqat97mj",
      "target": "e9m8urvkrcu",
      "value": -30.58516753885345
    },
    {
      "source": "yun3svzumda",
      "target": "e9m8urvkrcu",
      "value": 27.708102411949714
    },
    {
      "source": "d0l9pwlhh58",
      "target": "e9m8urvkrcu",
      "value": -47.331162170572256
    },
    {
      "source": "tz98ncky8x",
      "target": "e9m8urvkrcu",
      "value": 31.08540447268165
    },
    {
      "source": "f77px83jht",
      "target": "e9m8urvkrcu",
      "value": -22.305012977606445
    },
    {
      "source": "dorzctchp2f",
      "target": "e9m8urvkrcu",
      "value": -6.441437416777784
    },
    {
      "source": "bnhmg8ojmi",
      "target": "e9m8urvkrcu",
      "value": -0.2881224317164415
    },
    {
      "source": "jgv7zzikoz",
      "target": "e9m8urvkrcu",
      "value": -7.703903385743195
    },
    {
      "source": "bnhmg8ojmi",
      "target": "zkikpdy4lzr",
      "value": -3.111702606561253
    },
    {
      "source": "tz98ncky8x",
      "target": "zkikpdy4lzr",
      "value": -12.992094254672875
    },
    {
      "source": "fepi6iab718",
      "target": "zkikpdy4lzr",
      "value": 1.1930523875975103
    },
    {
      "source": "f77px83jht",
      "target": "zkikpdy4lzr",
      "value": 42.89584046935879
    },
    {
      "source": "dorzctchp2f",
      "target": "zkikpdy4lzr",
      "value": -32.27466630186921
    },
    {
      "source": "jgv7zzikoz",
      "target": "zkikpdy4lzr",
      "value": -7.876048195193241
    },
    {
      "source": "g2thoplak1c",
      "target": "zkikpdy4lzr",
      "value": -20.99790487444407
    },
    {
      "source": "a5t2qhljfb",
      "target": "zkikpdy4lzr",
      "value": 8.21939667248093
    },
    {
      "source": "imdituj5xjd",
      "target": "zkikpdy4lzr",
      "value": -12.021899459545661
    },
    {
      "source": "a5t2qhljfb",
      "target": "e9j0hw6zjka",
      "value": 21.25010772685053
    },
    {
      "source": "dorzctchp2f",
      "target": "e9j0hw6zjka",
      "value": -16.829861229685175
    },
    {
      "source": "bnhmg8ojmi",
      "target": "e9j0hw6zjka",
      "value": 2.9791345735221855
    },
    {
      "source": "jgv7zzikoz",
      "target": "e9j0hw6zjka",
      "value": 53.89535710088523
    },
    {
      "source": "g2thoplak1c",
      "target": "e9j0hw6zjka",
      "value": 38.91574427880547
    },
    {
      "source": "imdituj5xjd",
      "target": "e9j0hw6zjka",
      "value": -29.273960760634882
    },
    {
      "source": "s4jhju9ioi",
      "target": "e9j0hw6zjka",
      "value": 15.752362919185055
    },
    {
      "source": "vjzcmo4y5l",
      "target": "e9j0hw6zjka",
      "value": 18.788321247597988
    },
    {
      "source": "asyj3ayjz3",
      "target": "e9j0hw6zjka",
      "value": -4.9123556938164175
    },
    {
      "source": "vjzcmo4y5l",
      "target": "48o4q5q22kf",
      "value": 12.776660613920638
    },
    {
      "source": "g2thoplak1c",
      "target": "48o4q5q22kf",
      "value": 8.553470302447769
    },
    {
      "source": "a5t2qhljfb",
      "target": "48o4q5q22kf",
      "value": 0.1396315066433882
    },
    {
      "source": "imdituj5xjd",
      "target": "48o4q5q22kf",
      "value": -7.913802678153372
    },
    {
      "source": "s4jhju9ioi",
      "target": "48o4q5q22kf",
      "value": -19.958400048310917
    },
    {
      "source": "asyj3ayjz3",
      "target": "48o4q5q22kf",
      "value": -12.705725643224586
    },
    {
      "source": "81ll0y30qpx",
      "target": "48o4q5q22kf",
      "value": -0.7687739884284359
    },
    {
      "source": "i9h9tsiadt",
      "target": "48o4q5q22kf",
      "value": 24.059638094341295
    },
    {
      "source": "5r7qpsybzm",
      "target": "48o4q5q22kf",
      "value": -12.219069829735172
    },
    {
      "source": "i9h9tsiadt",
      "target": "le5qn0l5fo",
      "value": 38.98091638144858
    },
    {
      "source": "s4jhju9ioi",
      "target": "le5qn0l5fo",
      "value": -18.679512959197837
    },
    {
      "source": "vjzcmo4y5l",
      "target": "le5qn0l5fo",
      "value": -17.51999529902024
    },
    {
      "source": "asyj3ayjz3",
      "target": "le5qn0l5fo",
      "value": 7.231744953824184
    },
    {
      "source": "81ll0y30qpx",
      "target": "le5qn0l5fo",
      "value": 7.757857095855854
    },
    {
      "source": "5r7qpsybzm",
      "target": "le5qn0l5fo",
      "value": -14.675710272177016
    },
    {
      "source": "pgazjtga0ab",
      "target": "le5qn0l5fo",
      "value": 29.25256744271915
    },
    {
      "source": "8qmjxds6vq",
      "target": "le5qn0l5fo",
      "value": 12.019202466263158
    },
    {
      "source": "mt9ajyca4jb",
      "target": "le5qn0l5fo",
      "value": 17.36542237121401
    },
    {
      "source": "f77px83jht",
      "target": "e5eoamjn9wj",
      "value": 25.905371837253256
    },
    {
      "source": "yun3svzumda",
      "target": "e5eoamjn9wj",
      "value": 14.636034674186146
    },
    {
      "source": "d0l9pwlhh58",
      "target": "e5eoamjn9wj",
      "value": 9.295126566256119
    },
    {
      "source": "jiy9vgk3p6c",
      "target": "e5eoamjn9wj",
      "value": -40.11905600289941
    },
    {
      "source": "fepi6iab718",
      "target": "e5eoamjn9wj",
      "value": 28.847588944119746
    },
    {
      "source": "sovz0h6kg2",
      "target": "e5eoamjn9wj",
      "value": 27.82099960126386
    },
    {
      "source": "bnhmg8ojmi",
      "target": "e5eoamjn9wj",
      "value": 1.9448006468110126
    },
    {
      "source": "jgv7zzikoz",
      "target": "e5eoamjn9wj",
      "value": -43.58501885384509
    },
    {
      "source": "rsopcs57xp",
      "target": "e5eoamjn9wj",
      "value": 20.60315782141361
    },
    {
      "source": "jgv7zzikoz",
      "target": "485i3bszn4b",
      "value": 28.94966515561276
    },
    {
      "source": "fepi6iab718",
      "target": "485i3bszn4b",
      "value": -4.97706679488539
    },
    {
      "source": "f77px83jht",
      "target": "485i3bszn4b",
      "value": -9.309785610678572
    },
    {
      "source": "sovz0h6kg2",
      "target": "485i3bszn4b",
      "value": 1.623375897643961
    },
    {
      "source": "bnhmg8ojmi",
      "target": "485i3bszn4b",
      "value": 29.695807653416598
    },
    {
      "source": "rsopcs57xp",
      "target": "485i3bszn4b",
      "value": 30.00671465876635
    },
    {
      "source": "a5t2qhljfb",
      "target": "485i3bszn4b",
      "value": 14.806811169689272
    },
    {
      "source": "imdituj5xjd",
      "target": "485i3bszn4b",
      "value": -27.976974086409978
    },
    {
      "source": "365ja83vqlx",
      "target": "485i3bszn4b",
      "value": 5.313915200928251
    },
    {
      "source": "imdituj5xjd",
      "target": "q81oy0fxdx",
      "value": 20.10537965110058
    },
    {
      "source": "bnhmg8ojmi",
      "target": "q81oy0fxdx",
      "value": 14.625132698691733
    },
    {
      "source": "jgv7zzikoz",
      "target": "q81oy0fxdx",
      "value": 20.168016414398107
    },
    {
      "source": "rsopcs57xp",
      "target": "q81oy0fxdx",
      "value": 7.6436845402266504
    },
    {
      "source": "a5t2qhljfb",
      "target": "q81oy0fxdx",
      "value": 11.160474244240861
    },
    {
      "source": "365ja83vqlx",
      "target": "q81oy0fxdx",
      "value": -32.69688829087232
    },
    {
      "source": "vjzcmo4y5l",
      "target": "q81oy0fxdx",
      "value": -13.213519421309535
    },
    {
      "source": "asyj3ayjz3",
      "target": "q81oy0fxdx",
      "value": 26.738083734331475
    },
    {
      "source": "xu3zvbajwna",
      "target": "q81oy0fxdx",
      "value": 8.318934594285727
    },
    {
      "source": "asyj3ayjz3",
      "target": "o2cf5j2mqnb",
      "value": -8.63925926739146
    },
    {
      "source": "a5t2qhljfb",
      "target": "o2cf5j2mqnb",
      "value": 13.366666367372213
    },
    {
      "source": "imdituj5xjd",
      "target": "o2cf5j2mqnb",
      "value": 31.5096295562067
    },
    {
      "source": "365ja83vqlx",
      "target": "o2cf5j2mqnb",
      "value": -36.84649551201609
    },
    {
      "source": "vjzcmo4y5l",
      "target": "o2cf5j2mqnb",
      "value": 20.345054612998645
    },
    {
      "source": "xu3zvbajwna",
      "target": "o2cf5j2mqnb",
      "value": 0.24416466984615512
    },
    {
      "source": "i9h9tsiadt",
      "target": "o2cf5j2mqnb",
      "value": 11.537642136669641
    },
    {
      "source": "5r7qpsybzm",
      "target": "o2cf5j2mqnb",
      "value": -9.760394683506297
    },
    {
      "source": "q0xziza31k8",
      "target": "o2cf5j2mqnb",
      "value": 5.539714245848425
    },
    {
      "source": "5r7qpsybzm",
      "target": "xydml8hbx6i",
      "value": -16.45990625487847
    },
    {
      "source": "vjzcmo4y5l",
      "target": "xydml8hbx6i",
      "value": -18.139172970431346
    },
    {
      "source": "asyj3ayjz3",
      "target": "xydml8hbx6i",
      "value": -35.25147133455691
    },
    {
      "source": "xu3zvbajwna",
      "target": "xydml8hbx6i",
      "value": 23.476953613446465
    },
    {
      "source": "i9h9tsiadt",
      "target": "xydml8hbx6i",
      "value": -9.349791001841039
    },
    {
      "source": "q0xziza31k8",
      "target": "xydml8hbx6i",
      "value": -27.21143588499339
    },
    {
      "source": "8qmjxds6vq",
      "target": "xydml8hbx6i",
      "value": 10.099418807393533
    },
    {
      "source": "mt9ajyca4jb",
      "target": "xydml8hbx6i",
      "value": -35.34359958574753
    },
    {
      "source": "kfce4u3en1j",
      "target": "xydml8hbx6i",
      "value": 48.596335711133555
    },
    {
      "source": "sovz0h6kg2",
      "target": "ouye9washu",
      "value": 37.89719021833736
    },
    {
      "source": "d0l9pwlhh58",
      "target": "ouye9washu",
      "value": 4.724057219588254
    },
    {
      "source": "jiy9vgk3p6c",
      "target": "ouye9washu",
      "value": -44.577815155609336
    },
    {
      "source": "fhp87509j3w",
      "target": "ouye9washu",
      "value": 23.830744672476396
    },
    {
      "source": "f77px83jht",
      "target": "ouye9washu",
      "value": -25.196419803967984
    },
    {
      "source": "6q2ufizcipi",
      "target": "ouye9washu",
      "value": 33.77013184293128
    },
    {
      "source": "jgv7zzikoz",
      "target": "ouye9washu",
      "value": -23.277128828936647
    },
    {
      "source": "rsopcs57xp",
      "target": "ouye9washu",
      "value": -7.008659319582642
    },
    {
      "source": "pvl59v1bpl",
      "target": "ouye9washu",
      "value": -18.422015807887213
    },
    {
      "source": "rsopcs57xp",
      "target": "4jk8ybzo9m7",
      "value": -31.473183756181495
    },
    {
      "source": "f77px83jht",
      "target": "4jk8ybzo9m7",
      "value": 13.553472552912833
    },
    {
      "source": "sovz0h6kg2",
      "target": "4jk8ybzo9m7",
      "value": 25.782903998262853
    },
    {
      "source": "6q2ufizcipi",
      "target": "4jk8ybzo9m7",
      "value": -1.0974077612751874
    },
    {
      "source": "jgv7zzikoz",
      "target": "4jk8ybzo9m7",
      "value": -3.083849767229912
    },
    {
      "source": "pvl59v1bpl",
      "target": "4jk8ybzo9m7",
      "value": -25.825159806107077
    },
    {
      "source": "imdituj5xjd",
      "target": "4jk8ybzo9m7",
      "value": 14.441063645627171
    },
    {
      "source": "365ja83vqlx",
      "target": "4jk8ybzo9m7",
      "value": 0.8401835542299108
    },
    {
      "source": "mnjavoybnl",
      "target": "4jk8ybzo9m7",
      "value": 58.901000276646066
    },
    {
      "source": "365ja83vqlx",
      "target": "ccvxgu45qlf",
      "value": 25.82437270510144
    },
    {
      "source": "jgv7zzikoz",
      "target": "ccvxgu45qlf",
      "value": 13.95753919088931
    },
    {
      "source": "rsopcs57xp",
      "target": "ccvxgu45qlf",
      "value": 1.8641342556149545
    },
    {
      "source": "pvl59v1bpl",
      "target": "ccvxgu45qlf",
      "value": 43.92311523398861
    },
    {
      "source": "imdituj5xjd",
      "target": "ccvxgu45qlf",
      "value": -2.3946388491416126
    },
    {
      "source": "mnjavoybnl",
      "target": "ccvxgu45qlf",
      "value": 29.39926653636569
    },
    {
      "source": "asyj3ayjz3",
      "target": "ccvxgu45qlf",
      "value": 35.39393892560413
    },
    {
      "source": "xu3zvbajwna",
      "target": "ccvxgu45qlf",
      "value": -10.803768448470471
    },
    {
      "source": "jcqx6i2ejd7",
      "target": "ccvxgu45qlf",
      "value": -31.362501927591143
    },
    {
      "source": "xu3zvbajwna",
      "target": "lcv04zvdygl",
      "value": 5.625083427340248
    },
    {
      "source": "imdituj5xjd",
      "target": "lcv04zvdygl",
      "value": 38.64706040058687
    },
    {
      "source": "365ja83vqlx",
      "target": "lcv04zvdygl",
      "value": 18.37383737354021
    },
    {
      "source": "mnjavoybnl",
      "target": "lcv04zvdygl",
      "value": -8.871877175549502
    },
    {
      "source": "asyj3ayjz3",
      "target": "lcv04zvdygl",
      "value": 24.335515705519693
    },
    {
      "source": "jcqx6i2ejd7",
      "target": "lcv04zvdygl",
      "value": 42.44796962089829
    },
    {
      "source": "5r7qpsybzm",
      "target": "lcv04zvdygl",
      "value": -8.422202474164807
    },
    {
      "source": "q0xziza31k8",
      "target": "lcv04zvdygl",
      "value": -16.6939867318066
    },
    {
      "source": "qrwq6wrrkdc",
      "target": "lcv04zvdygl",
      "value": 9.046153635965238
    },
    {
      "source": "q0xziza31k8",
      "target": "d776fr0467h",
      "value": -42.26585226316051
    },
    {
      "source": "asyj3ayjz3",
      "target": "d776fr0467h",
      "value": -6.0660119926374625
    },
    {
      "source": "xu3zvbajwna",
      "target": "d776fr0467h",
      "value": -45.52791550641014
    },
    {
      "source": "jcqx6i2ejd7",
      "target": "d776fr0467h",
      "value": 16.488672130983552
    },
    {
      "source": "5r7qpsybzm",
      "target": "d776fr0467h",
      "value": 27.19579157612253
    },
    {
      "source": "qrwq6wrrkdc",
      "target": "d776fr0467h",
      "value": 0.42676282090358897
    },
    {
      "source": "mt9ajyca4jb",
      "target": "d776fr0467h",
      "value": -33.91719679814476
    },
    {
      "source": "kfce4u3en1j",
      "target": "d776fr0467h",
      "value": 46.279581599933834
    },
    {
      "source": "bhcmhr9mslp",
      "target": "d776fr0467h",
      "value": 7.536883587813778
    },
    {
      "source": "6q2ufizcipi",
      "target": "g4ibepebmt6",
      "value": 58.66769531906053
    },
    {
      "source": "jiy9vgk3p6c",
      "target": "g4ibepebmt6",
      "value": 6.888661813126535
    },
    {
      "source": "fhp87509j3w",
      "target": "g4ibepebmt6",
      "value": 32.7188727627332
    },
    {
      "source": "i2gya8prn7s",
      "target": "g4ibepebmt6",
      "value": -2.0666504738374067
    },
    {
      "source": "sovz0h6kg2",
      "target": "g4ibepebmt6",
      "value": -26.780943648972176
    },
    {
      "source": "cthe1awnh2i",
      "target": "g4ibepebmt6",
      "value": -13.46622834287417
    },
    {
      "source": "rsopcs57xp",
      "target": "g4ibepebmt6",
      "value": 11.812763830413095
    },
    {
      "source": "pvl59v1bpl",
      "target": "g4ibepebmt6",
      "value": 11.333469684684523
    },
    {
      "source": "ffrmo49ajan",
      "target": "g4ibepebmt6",
      "value": -0.4696238683684725
    },
    {
      "source": "pvl59v1bpl",
      "target": "v39pxc7w1yo",
      "value": 32.513613052512376
    },
    {
      "source": "sovz0h6kg2",
      "target": "v39pxc7w1yo",
      "value": 37.189040391797896
    },
    {
      "source": "6q2ufizcipi",
      "target": "v39pxc7w1yo",
      "value": -20.95763546223076
    },
    {
      "source": "cthe1awnh2i",
      "target": "v39pxc7w1yo",
      "value": -7.5891715995695925
    },
    {
      "source": "rsopcs57xp",
      "target": "v39pxc7w1yo",
      "value": -5.201714766020843
    },
    {
      "source": "ffrmo49ajan",
      "target": "v39pxc7w1yo",
      "value": 30.067650447771705
    },
    {
      "source": "365ja83vqlx",
      "target": "v39pxc7w1yo",
      "value": 18.963703343312343
    },
    {
      "source": "mnjavoybnl",
      "target": "v39pxc7w1yo",
      "value": 3.6487951450161127
    },
    {
      "source": "ahuk95vg76s",
      "target": "v39pxc7w1yo",
      "value": 3.0263260854123475
    },
    {
      "source": "mnjavoybnl",
      "target": "wosf8yjbujp",
      "value": -21.927770681614376
    },
    {
      "source": "rsopcs57xp",
      "target": "wosf8yjbujp",
      "value": 19.603983811494025
    },
    {
      "source": "pvl59v1bpl",
      "target": "wosf8yjbujp",
      "value": -7.014892319055512
    },
    {
      "source": "ffrmo49ajan",
      "target": "wosf8yjbujp",
      "value": 13.966073347892769
    },
    {
      "source": "365ja83vqlx",
      "target": "wosf8yjbujp",
      "value": -15.816484663798994
    },
    {
      "source": "ahuk95vg76s",
      "target": "wosf8yjbujp",
      "value": 20.71005184118127
    },
    {
      "source": "xu3zvbajwna",
      "target": "wosf8yjbujp",
      "value": -8.350340812519125
    },
    {
      "source": "jcqx6i2ejd7",
      "target": "wosf8yjbujp",
      "value": -4.269501844109162
    },
    {
      "source": "qpb0jk3x57",
      "target": "wosf8yjbujp",
      "value": 16.59219747195636
    },
    {
      "source": "jcqx6i2ejd7",
      "target": "g7pablxhbfm",
      "value": 21.247005557174354
    },
    {
      "source": "365ja83vqlx",
      "target": "g7pablxhbfm",
      "value": -33.69547819837689
    },
    {
      "source": "mnjavoybnl",
      "target": "g7pablxhbfm",
      "value": -18.68725412354312
    },
    {
      "source": "ahuk95vg76s",
      "target": "g7pablxhbfm",
      "value": 8.317011056964423
    },
    {
      "source": "xu3zvbajwna",
      "target": "g7pablxhbfm",
      "value": 54.115845710956116
    },
    {
      "source": "qpb0jk3x57",
      "target": "g7pablxhbfm",
      "value": -8.931555226781446
    },
    {
      "source": "q0xziza31k8",
      "target": "g7pablxhbfm",
      "value": -68.315101742563
    },
    {
      "source": "qrwq6wrrkdc",
      "target": "g7pablxhbfm",
      "value": -29.668815109934258
    },
    {
      "source": "pvdthg12hf",
      "target": "g7pablxhbfm",
      "value": 25.911167455244218
    },
    {
      "source": "qrwq6wrrkdc",
      "target": "k1thp962qe",
      "value": 44.23086717623828
    },
    {
      "source": "xu3zvbajwna",
      "target": "k1thp962qe",
      "value": 23.701361232642412
    },
    {
      "source": "jcqx6i2ejd7",
      "target": "k1thp962qe",
      "value": -57.84959038069287
    },
    {
      "source": "qpb0jk3x57",
      "target": "k1thp962qe",
      "value": -7.139888443377377
    },
    {
      "source": "q0xziza31k8",
      "target": "k1thp962qe",
      "value": -20.050647146325353
    },
    {
      "source": "pvdthg12hf",
      "target": "k1thp962qe",
      "value": -18.550531211921093
    },
    {
      "source": "kfce4u3en1j",
      "target": "k1thp962qe",
      "value": -2.0742047856011863
    },
    {
      "source": "bhcmhr9mslp",
      "target": "k1thp962qe",
      "value": 7.1853785595240245
    },
    {
      "source": "ubb6v94cv6",
      "target": "k1thp962qe",
      "value": 52.28588738527051
    },
    {
      "source": "cthe1awnh2i",
      "target": "yqk0bvuib1",
      "value": -16.325147233076883
    },
    {
      "source": "fhp87509j3w",
      "target": "yqk0bvuib1",
      "value": 9.18664881507037
    },
    {
      "source": "i2gya8prn7s",
      "target": "yqk0bvuib1",
      "value": 26.473951497714317
    },
    {
      "source": "iiqhub9j9t",
      "target": "yqk0bvuib1",
      "value": 26.260161414838855
    },
    {
      "source": "6q2ufizcipi",
      "target": "yqk0bvuib1",
      "value": -21.18577639831681
    },
    {
      "source": "frlysobaw8j",
      "target": "yqk0bvuib1",
      "value": 54.79253462200977
    },
    {
      "source": "pvl59v1bpl",
      "target": "yqk0bvuib1",
      "value": 3.2988389889968976
    },
    {
      "source": "ffrmo49ajan",
      "target": "yqk0bvuib1",
      "value": -35.24122904394917
    },
    {
      "source": "nz61iv5fw6p",
      "target": "yqk0bvuib1",
      "value": 38.72719596652071
    },
    {
      "source": "ffrmo49ajan",
      "target": "a02nydyxp6n",
      "value": 0.8952197521003994
    },
    {
      "source": "6q2ufizcipi",
      "target": "a02nydyxp6n",
      "value": -2.828893215062807
    },
    {
      "source": "cthe1awnh2i",
      "target": "a02nydyxp6n",
      "value": -15.095907196188781
    },
    {
      "source": "frlysobaw8j",
      "target": "a02nydyxp6n",
      "value": 33.3905372956949
    },
    {
      "source": "pvl59v1bpl",
      "target": "a02nydyxp6n",
      "value": -71.96726211747871
    },
    {
      "source": "nz61iv5fw6p",
      "target": "a02nydyxp6n",
      "value": 5.181625827717319
    },
    {
      "source": "mnjavoybnl",
      "target": "a02nydyxp6n",
      "value": -7.294926535709603
    },
    {
      "source": "ahuk95vg76s",
      "target": "a02nydyxp6n",
      "value": 32.68391329321207
    },
    {
      "source": "oso3eprfwum",
      "target": "a02nydyxp6n",
      "value": -15.066299673902911
    },
    {
      "source": "ahuk95vg76s",
      "target": "vh74f1yqsii",
      "value": 29.075866800966974
    },
    {
      "source": "pvl59v1bpl",
      "target": "vh74f1yqsii",
      "value": 5.287952404275444
    },
    {
      "source": "ffrmo49ajan",
      "target": "vh74f1yqsii",
      "value": -16.04783899909567
    },
    {
      "source": "nz61iv5fw6p",
      "target": "vh74f1yqsii",
      "value": -40.94086911302427
    },
    {
      "source": "mnjavoybnl",
      "target": "vh74f1yqsii",
      "value": 12.376694522602975
    },
    {
      "source": "oso3eprfwum",
      "target": "vh74f1yqsii",
      "value": 0.5571971876134979
    },
    {
      "source": "jcqx6i2ejd7",
      "target": "vh74f1yqsii",
      "value": 22.884401805981835
    },
    {
      "source": "qpb0jk3x57",
      "target": "vh74f1yqsii",
      "value": -31.848066601032762
    },
    {
      "source": "gtlcc3bdmmo",
      "target": "vh74f1yqsii",
      "value": 46.936664209650196
    },
    {
      "source": "qpb0jk3x57",
      "target": "yqev545p6ag",
      "value": -43.03564904129236
    },
    {
      "source": "mnjavoybnl",
      "target": "yqev545p6ag",
      "value": 10.230691089091248
    },
    {
      "source": "ahuk95vg76s",
      "target": "yqev545p6ag",
      "value": 9.62861207624245
    },
    {
      "source": "oso3eprfwum",
      "target": "yqev545p6ag",
      "value": 25.681236911620815
    },
    {
      "source": "jcqx6i2ejd7",
      "target": "yqev545p6ag",
      "value": 52.12463573160662
    },
    {
      "source": "gtlcc3bdmmo",
      "target": "yqev545p6ag",
      "value": 14.357309203180812
    },
    {
      "source": "qrwq6wrrkdc",
      "target": "yqev545p6ag",
      "value": -22.53041933323167
    },
    {
      "source": "pvdthg12hf",
      "target": "yqev545p6ag",
      "value": 14.962641150077506
    },
    {
      "source": "ykrys8i8ejh",
      "target": "yqev545p6ag",
      "value": -12.1009960051829
    },
    {
      "source": "pvdthg12hf",
      "target": "ij2lsmyzo1h",
      "value": -3.207191094848077
    },
    {
      "source": "jcqx6i2ejd7",
      "target": "ij2lsmyzo1h",
      "value": -38.5371572072866
    },
    {
      "source": "qpb0jk3x57",
      "target": "ij2lsmyzo1h",
      "value": -30.250360926520983
    },
    {
      "source": "gtlcc3bdmmo",
      "target": "ij2lsmyzo1h",
      "value": -22.862256779043182
    },
    {
      "source": "qrwq6wrrkdc",
      "target": "ij2lsmyzo1h",
      "value": 1.1066620467808002
    },
    {
      "source": "ykrys8i8ejh",
      "target": "ij2lsmyzo1h",
      "value": 18.45026068123006
    },
    {
      "source": "bhcmhr9mslp",
      "target": "ij2lsmyzo1h",
      "value": 11.663623677505857
    },
    {
      "source": "ubb6v94cv6",
      "target": "ij2lsmyzo1h",
      "value": -31.027984657490848
    },
    {
      "source": "p07y3qfyelf",
      "target": "ij2lsmyzo1h",
      "value": 5.443569118740147
    },
    {
      "source": "e9m8urvkrcu",
      "target": "4wlce5ldwuo",
      "value": -9.757078972606136
    },
    {
      "source": "e9m8urvkrcu",
      "target": "9i84r5pz09",
      "value": 21.123546948567014
    },
    {
      "source": "e9m8urvkrcu",
      "target": "fuis6jhff0v",
      "value": 27.514234479892362
    },
    {
      "source": "e9m8urvkrcu",
      "target": "gggfnldg4gv",
      "value": -28.831658490721164
    },
    {
      "source": "zkikpdy4lzr",
      "target": "4wlce5ldwuo",
      "value": 7.520440912899239
    },
    {
      "source": "zkikpdy4lzr",
      "target": "9i84r5pz09",
      "value": 12.398623210918142
    },
    {
      "source": "zkikpdy4lzr",
      "target": "fuis6jhff0v",
      "value": -23.02598682993607
    },
    {
      "source": "zkikpdy4lzr",
      "target": "gggfnldg4gv",
      "value": 47.14380493169919
    },
    {
      "source": "e9j0hw6zjka",
      "target": "4wlce5ldwuo",
      "value": -1.3477560325909377
    },
    {
      "source": "e9j0hw6zjka",
      "target": "9i84r5pz09",
      "value": -14.958914856798826
    },
    {
      "source": "e9j0hw6zjka",
      "target": "fuis6jhff0v",
      "value": -17.26776772825695
    },
    {
      "source": "e9j0hw6zjka",
      "target": "gggfnldg4gv",
      "value": -4.515548772805644
    },
    {
      "source": "48o4q5q22kf",
      "target": "4wlce5ldwuo",
      "value": -7.4598994571106605
    },
    {
      "source": "48o4q5q22kf",
      "target": "9i84r5pz09",
      "value": -48.04135529255984
    },
    {
      "source": "48o4q5q22kf",
      "target": "fuis6jhff0v",
      "value": 30.18931850730202
    },
    {
      "source": "48o4q5q22kf",
      "target": "gggfnldg4gv",
      "value": 0.3886482641834844
    },
    {
      "source": "le5qn0l5fo",
      "target": "4wlce5ldwuo",
      "value": -5.56686188842676
    },
    {
      "source": "le5qn0l5fo",
      "target": "9i84r5pz09",
      "value": -26.321127536941102
    },
    {
      "source": "le5qn0l5fo",
      "target": "fuis6jhff0v",
      "value": 29.562788762627996
    },
    {
      "source": "le5qn0l5fo",
      "target": "gggfnldg4gv",
      "value": -23.155443589044353
    },
    {
      "source": "e5eoamjn9wj",
      "target": "4wlce5ldwuo",
      "value": 1.278679967625869
    },
    {
      "source": "e5eoamjn9wj",
      "target": "9i84r5pz09",
      "value": 3.0149765749667123
    },
    {
      "source": "e5eoamjn9wj",
      "target": "fuis6jhff0v",
      "value": -14.207074931402584
    },
    {
      "source": "e5eoamjn9wj",
      "target": "gggfnldg4gv",
      "value": 9.944029353616944
    },
    {
      "source": "485i3bszn4b",
      "target": "4wlce5ldwuo",
      "value": -19.562759631115565
    },
    {
      "source": "485i3bszn4b",
      "target": "9i84r5pz09",
      "value": -5.479290951863921
    },
    {
      "source": "485i3bszn4b",
      "target": "fuis6jhff0v",
      "value": 18.58404269681246
    },
    {
      "source": "485i3bszn4b",
      "target": "gggfnldg4gv",
      "value": 38.07528310664379
    },
    {
      "source": "q81oy0fxdx",
      "target": "4wlce5ldwuo",
      "value": -38.874006061108396
    },
    {
      "source": "q81oy0fxdx",
      "target": "9i84r5pz09",
      "value": 13.778456193684663
    },
    {
      "source": "q81oy0fxdx",
      "target": "fuis6jhff0v",
      "value": -0.8324990744863225
    },
    {
      "source": "q81oy0fxdx",
      "target": "gggfnldg4gv",
      "value": 57.14756096069459
    },
    {
      "source": "o2cf5j2mqnb",
      "target": "4wlce5ldwuo",
      "value": 17.993962609363447
    },
    {
      "source": "o2cf5j2mqnb",
      "target": "9i84r5pz09",
      "value": 5.146200352382416
    },
    {
      "source": "o2cf5j2mqnb",
      "target": "fuis6jhff0v",
      "value": 8.877429612425543
    },
    {
      "source": "o2cf5j2mqnb",
      "target": "gggfnldg4gv",
      "value": -16.995338631764483
    },
    {
      "source": "xydml8hbx6i",
      "target": "4wlce5ldwuo",
      "value": -7.968343581676189
    },
    {
      "source": "xydml8hbx6i",
      "target": "9i84r5pz09",
      "value": 7.049535613855116
    },
    {
      "source": "xydml8hbx6i",
      "target": "fuis6jhff0v",
      "value": 20.65839067666224
    },
    {
      "source": "xydml8hbx6i",
      "target": "gggfnldg4gv",
      "value": -4.475531213452242
    },
    {
      "source": "ouye9washu",
      "target": "4wlce5ldwuo",
      "value": -37.750552005754265
    },
    {
      "source": "ouye9washu",
      "target": "9i84r5pz09",
      "value": 15.644921533927402
    },
    {
      "source": "ouye9washu",
      "target": "fuis6jhff0v",
      "value": -7.050211294769852
    },
    {
      "source": "ouye9washu",
      "target": "gggfnldg4gv",
      "value": 11.851649946823343
    },
    {
      "source": "4jk8ybzo9m7",
      "target": "4wlce5ldwuo",
      "value": -24.89776938492078
    },
    {
      "source": "4jk8ybzo9m7",
      "target": "9i84r5pz09",
      "value": -21.303387355690283
    },
    {
      "source": "4jk8ybzo9m7",
      "target": "fuis6jhff0v",
      "value": -22.037143897722192
    },
    {
      "source": "4jk8ybzo9m7",
      "target": "gggfnldg4gv",
      "value": 14.069660762281927
    },
    {
      "source": "ccvxgu45qlf",
      "target": "4wlce5ldwuo",
      "value": 24.86938120389194
    },
    {
      "source": "ccvxgu45qlf",
      "target": "9i84r5pz09",
      "value": 37.200587269638326
    },
    {
      "source": "ccvxgu45qlf",
      "target": "fuis6jhff0v",
      "value": -3.1307013232840792
    },
    {
      "source": "ccvxgu45qlf",
      "target": "gggfnldg4gv",
      "value": 26.53229609480352
    },
    {
      "source": "lcv04zvdygl",
      "target": "4wlce5ldwuo",
      "value": 15.649530174700459
    },
    {
      "source": "lcv04zvdygl",
      "target": "9i84r5pz09",
      "value": -23.775981321083336
    },
    {
      "source": "lcv04zvdygl",
      "target": "fuis6jhff0v",
      "value": 37.40573184890457
    },
    {
      "source": "lcv04zvdygl",
      "target": "gggfnldg4gv",
      "value": 7.590931129264332
    },
    {
      "source": "d776fr0467h",
      "target": "4wlce5ldwuo",
      "value": 31.018006351615007
    },
    {
      "source": "d776fr0467h",
      "target": "9i84r5pz09",
      "value": -12.005274963143385
    },
    {
      "source": "d776fr0467h",
      "target": "fuis6jhff0v",
      "value": 14.589575163564191
    },
    {
      "source": "d776fr0467h",
      "target": "gggfnldg4gv",
      "value": -29.835074333293008
    },
    {
      "source": "g4ibepebmt6",
      "target": "4wlce5ldwuo",
      "value": 19.838660060923836
    },
    {
      "source": "g4ibepebmt6",
      "target": "9i84r5pz09",
      "value": -16.84795120882376
    },
    {
      "source": "g4ibepebmt6",
      "target": "fuis6jhff0v",
      "value": 72.43982900710877
    },
    {
      "source": "g4ibepebmt6",
      "target": "gggfnldg4gv",
      "value": 34.35106902402252
    },
    {
      "source": "v39pxc7w1yo",
      "target": "4wlce5ldwuo",
      "value": 36.96616319905094
    },
    {
      "source": "v39pxc7w1yo",
      "target": "9i84r5pz09",
      "value": 3.157780782008114
    },
    {
      "source": "v39pxc7w1yo",
      "target": "fuis6jhff0v",
      "value": -12.921330148638143
    },
    {
      "source": "v39pxc7w1yo",
      "target": "gggfnldg4gv",
      "value": 6.837315501127672
    },
    {
      "source": "wosf8yjbujp",
      "target": "4wlce5ldwuo",
      "value": -11.893823646715123
    },
    {
      "source": "wosf8yjbujp",
      "target": "9i84r5pz09",
      "value": -27.651157047005874
    },
    {
      "source": "wosf8yjbujp",
      "target": "fuis6jhff0v",
      "value": 65.41299398648233
    },
    {
      "source": "wosf8yjbujp",
      "target": "gggfnldg4gv",
      "value": 14.628380815197142
    },
    {
      "source": "g7pablxhbfm",
      "target": "4wlce5ldwuo",
      "value": -4.032370239150668
    },
    {
      "source": "g7pablxhbfm",
      "target": "9i84r5pz09",
      "value": 33.58579333721673
    },
    {
      "source": "g7pablxhbfm",
      "target": "fuis6jhff0v",
      "value": 26.532047825730277
    },
    {
      "source": "g7pablxhbfm",
      "target": "gggfnldg4gv",
      "value": 0.8113199666925124
    },
    {
      "source": "k1thp962qe",
      "target": "4wlce5ldwuo",
      "value": 16.029887694923318
    },
    {
      "source": "k1thp962qe",
      "target": "9i84r5pz09",
      "value": -38.46063577370823
    },
    {
      "source": "k1thp962qe",
      "target": "fuis6jhff0v",
      "value": 17.729196074452382
    },
    {
      "source": "k1thp962qe",
      "target": "gggfnldg4gv",
      "value": -29.462270827859154
    },
    {
      "source": "yqk0bvuib1",
      "target": "4wlce5ldwuo",
      "value": -9.19787333270863
    },
    {
      "source": "yqk0bvuib1",
      "target": "9i84r5pz09",
      "value": 0.42037403978577514
    },
    {
      "source": "yqk0bvuib1",
      "target": "fuis6jhff0v",
      "value": -10.679623993600663
    },
    {
      "source": "yqk0bvuib1",
      "target": "gggfnldg4gv",
      "value": 25.789771625971035
    },
    {
      "source": "a02nydyxp6n",
      "target": "4wlce5ldwuo",
      "value": -29.091336758299903
    },
    {
      "source": "a02nydyxp6n",
      "target": "9i84r5pz09",
      "value": 3.9300023259102885
    },
    {
      "source": "a02nydyxp6n",
      "target": "fuis6jhff0v",
      "value": -7.096069620913169
    },
    {
      "source": "a02nydyxp6n",
      "target": "gggfnldg4gv",
      "value": -10.985396532206664
    },
    {
      "source": "vh74f1yqsii",
      "target": "4wlce5ldwuo",
      "value": -13.112966844342802
    },
    {
      "source": "vh74f1yqsii",
      "target": "9i84r5pz09",
      "value": 56.29505364145657
    },
    {
      "source": "vh74f1yqsii",
      "target": "fuis6jhff0v",
      "value": -26.261254933240934
    },
    {
      "source": "vh74f1yqsii",
      "target": "gggfnldg4gv",
      "value": 53.86350721940784
    },
    {
      "source": "yqev545p6ag",
      "target": "4wlce5ldwuo",
      "value": -55.57949470132372
    },
    {
      "source": "yqev545p6ag",
      "target": "9i84r5pz09",
      "value": -28.698587675897105
    },
    {
      "source": "yqev545p6ag",
      "target": "fuis6jhff0v",
      "value": -5.291162489518117
    },
    {
      "source": "yqev545p6ag",
      "target": "gggfnldg4gv",
      "value": -4.756996718710347
    },
    {
      "source": "ij2lsmyzo1h",
      "target": "4wlce5ldwuo",
      "value": 13.824883661045135
    },
    {
      "source": "ij2lsmyzo1h",
      "target": "9i84r5pz09",
      "value": 3.628258321168863
    },
    {
      "source": "ij2lsmyzo1h",
      "target": "fuis6jhff0v",
      "value": 63.93043883389326
    },
    {
      "source": "ij2lsmyzo1h",
      "target": "gggfnldg4gv",
      "value": 1.9752583367753072
    },
    {
      "source": "e9m8urvkrcu",
      "target": "mti2qoy08rm",
      "value": -6.44393485045443
    },
    {
      "source": "zkikpdy4lzr",
      "target": "mti2qoy08rm",
      "value": -42.70012038590219
    },
    {
      "source": "e9j0hw6zjka",
      "target": "mti2qoy08rm",
      "value": 6.9655257513010325
    },
    {
      "source": "48o4q5q22kf",
      "target": "mti2qoy08rm",
      "value": -9.98964441620321
    },
    {
      "source": "le5qn0l5fo",
      "target": "mti2qoy08rm",
      "value": -26.854980566425482
    },
    {
      "source": "e5eoamjn9wj",
      "target": "mti2qoy08rm",
      "value": -8.852161784698337
    },
    {
      "source": "485i3bszn4b",
      "target": "mti2qoy08rm",
      "value": 7.693050909587911
    },
    {
      "source": "q81oy0fxdx",
      "target": "mti2qoy08rm",
      "value": 39.79396992218251
    },
    {
      "source": "o2cf5j2mqnb",
      "target": "mti2qoy08rm",
      "value": -9.378301298928672
    },
    {
      "source": "xydml8hbx6i",
      "target": "mti2qoy08rm",
      "value": -2.611815688248074
    },
    {
      "source": "ouye9washu",
      "target": "mti2qoy08rm",
      "value": 13.403988530153711
    },
    {
      "source": "4jk8ybzo9m7",
      "target": "mti2qoy08rm",
      "value": 5.539323641976833
    },
    {
      "source": "ccvxgu45qlf",
      "target": "mti2qoy08rm",
      "value": 28.488687671419143
    },
    {
      "source": "lcv04zvdygl",
      "target": "mti2qoy08rm",
      "value": 5.855873384567136
    },
    {
      "source": "d776fr0467h",
      "target": "mti2qoy08rm",
      "value": -82.61151808866526
    },
    {
      "source": "g4ibepebmt6",
      "target": "mti2qoy08rm",
      "value": 5.471280637985636
    },
    {
      "source": "v39pxc7w1yo",
      "target": "mti2qoy08rm",
      "value": 36.36885881308753
    },
    {
      "source": "wosf8yjbujp",
      "target": "mti2qoy08rm",
      "value": -33.91161266968421
    },
    {
      "source": "g7pablxhbfm",
      "target": "mti2qoy08rm",
      "value": -36.32705998643252
    },
    {
      "source": "k1thp962qe",
      "target": "mti2qoy08rm",
      "value": 47.01283557267428
    },
    {
      "source": "yqk0bvuib1",
      "target": "mti2qoy08rm",
      "value": -42.90659622582588
    },
    {
      "source": "a02nydyxp6n",
      "target": "mti2qoy08rm",
      "value": -1.274123310306897
    },
    {
      "source": "vh74f1yqsii",
      "target": "mti2qoy08rm",
      "value": -18.502581952510358
    },
    {
      "source": "yqev545p6ag",
      "target": "mti2qoy08rm",
      "value": 29.728521963174963
    },
    {
      "source": "ij2lsmyzo1h",
      "target": "mti2qoy08rm",
      "value": -3.507723226316912
    },
    {
      "source": "4wlce5ldwuo",
      "target": "mti2qoy08rm",
      "value": -3.6169417946283335
    },
    {
      "source": "9i84r5pz09",
      "target": "mti2qoy08rm",
      "value": -41.03531971026109
    },
    {
      "source": "fuis6jhff0v",
      "target": "mti2qoy08rm",
      "value": 62.68271910742937
    },
    {
      "source": "gggfnldg4gv",
      "target": "mti2qoy08rm",
      "value": -8.110402579376052
    }
  ]
}
},{}],2:[function(require,module,exports){
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    var TempCtor = function () {}
    TempCtor.prototype = superCtor.prototype
    ctor.prototype = new TempCtor()
    ctor.prototype.constructor = ctor
  }
}

},{}],3:[function(require,module,exports){
// A library of seedable RNGs implemented in Javascript.
//
// Usage:
//
// var seedrandom = require('seedrandom');
// var random = seedrandom(1); // or any seed.
// var x = random();       // 0 <= x < 1.  Every bit is random.
// var x = random.quick(); // 0 <= x < 1.  32 bits of randomness.

// alea, a 53-bit multiply-with-carry generator by Johannes Baagøe.
// Period: ~2^116
// Reported to pass all BigCrush tests.
var alea = require('./lib/alea');

// xor128, a pure xor-shift generator by George Marsaglia.
// Period: 2^128-1.
// Reported to fail: MatrixRank and LinearComp.
var xor128 = require('./lib/xor128');

// xorwow, George Marsaglia's 160-bit xor-shift combined plus weyl.
// Period: 2^192-2^32
// Reported to fail: CollisionOver, SimpPoker, and LinearComp.
var xorwow = require('./lib/xorwow');

// xorshift7, by François Panneton and Pierre L'ecuyer, takes
// a different approach: it adds robustness by allowing more shifts
// than Marsaglia's original three.  It is a 7-shift generator
// with 256 bits, that passes BigCrush with no systmatic failures.
// Period 2^256-1.
// No systematic BigCrush failures reported.
var xorshift7 = require('./lib/xorshift7');

// xor4096, by Richard Brent, is a 4096-bit xor-shift with a
// very long period that also adds a Weyl generator. It also passes
// BigCrush with no systematic failures.  Its long period may
// be useful if you have many generators and need to avoid
// collisions.
// Period: 2^4128-2^32.
// No systematic BigCrush failures reported.
var xor4096 = require('./lib/xor4096');

// Tyche-i, by Samuel Neves and Filipe Araujo, is a bit-shifting random
// number generator derived from ChaCha, a modern stream cipher.
// https://eden.dei.uc.pt/~sneves/pubs/2011-snfa2.pdf
// Period: ~2^127
// No systematic BigCrush failures reported.
var tychei = require('./lib/tychei');

// The original ARC4-based prng included in this library.
// Period: ~2^1600
var sr = require('./seedrandom');

sr.alea = alea;
sr.xor128 = xor128;
sr.xorwow = xorwow;
sr.xorshift7 = xorshift7;
sr.xor4096 = xor4096;
sr.tychei = tychei;

module.exports = sr;

},{"./lib/alea":4,"./lib/tychei":5,"./lib/xor128":6,"./lib/xor4096":7,"./lib/xorshift7":8,"./lib/xorwow":9,"./seedrandom":10}],4:[function(require,module,exports){
// A port of an algorithm by Johannes Baagøe <baagoe@baagoe.com>, 2010
// http://baagoe.com/en/RandomMusings/javascript/
// https://github.com/nquinlan/better-random-numbers-for-javascript-mirror
// Original work is under MIT license -

// Copyright (C) 2010 by Johannes Baagøe <baagoe@baagoe.org>
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
// 
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.



(function(global, module, define) {

function Alea(seed) {
  var me = this, mash = Mash();

  me.next = function() {
    var t = 2091639 * me.s0 + me.c * 2.3283064365386963e-10; // 2^-32
    me.s0 = me.s1;
    me.s1 = me.s2;
    return me.s2 = t - (me.c = t | 0);
  };

  // Apply the seeding algorithm from Baagoe.
  me.c = 1;
  me.s0 = mash(' ');
  me.s1 = mash(' ');
  me.s2 = mash(' ');
  me.s0 -= mash(seed);
  if (me.s0 < 0) { me.s0 += 1; }
  me.s1 -= mash(seed);
  if (me.s1 < 0) { me.s1 += 1; }
  me.s2 -= mash(seed);
  if (me.s2 < 0) { me.s2 += 1; }
  mash = null;
}

function copy(f, t) {
  t.c = f.c;
  t.s0 = f.s0;
  t.s1 = f.s1;
  t.s2 = f.s2;
  return t;
}

function impl(seed, opts) {
  var xg = new Alea(seed),
      state = opts && opts.state,
      prng = xg.next;
  prng.int32 = function() { return (xg.next() * 0x100000000) | 0; }
  prng.double = function() {
    return prng() + (prng() * 0x200000 | 0) * 1.1102230246251565e-16; // 2^-53
  };
  prng.quick = prng;
  if (state) {
    if (typeof(state) == 'object') copy(state, xg);
    prng.state = function() { return copy(xg, {}); }
  }
  return prng;
}

function Mash() {
  var n = 0xefc8249d;

  var mash = function(data) {
    data = data.toString();
    for (var i = 0; i < data.length; i++) {
      n += data.charCodeAt(i);
      var h = 0.02519603282416938 * n;
      n = h >>> 0;
      h -= n;
      h *= n;
      n = h >>> 0;
      h -= n;
      n += h * 0x100000000; // 2^32
    }
    return (n >>> 0) * 2.3283064365386963e-10; // 2^-32
  };

  return mash;
}


if (module && module.exports) {
  module.exports = impl;
} else if (define && define.amd) {
  define(function() { return impl; });
} else {
  this.alea = impl;
}

})(
  this,
  (typeof module) == 'object' && module,    // present in node.js
  (typeof define) == 'function' && define   // present with an AMD loader
);



},{}],5:[function(require,module,exports){
// A Javascript implementaion of the "Tyche-i" prng algorithm by
// Samuel Neves and Filipe Araujo.
// See https://eden.dei.uc.pt/~sneves/pubs/2011-snfa2.pdf

(function(global, module, define) {

function XorGen(seed) {
  var me = this, strseed = '';

  // Set up generator function.
  me.next = function() {
    var b = me.b, c = me.c, d = me.d, a = me.a;
    b = (b << 25) ^ (b >>> 7) ^ c;
    c = (c - d) | 0;
    d = (d << 24) ^ (d >>> 8) ^ a;
    a = (a - b) | 0;
    me.b = b = (b << 20) ^ (b >>> 12) ^ c;
    me.c = c = (c - d) | 0;
    me.d = (d << 16) ^ (c >>> 16) ^ a;
    return me.a = (a - b) | 0;
  };

  /* The following is non-inverted tyche, which has better internal
   * bit diffusion, but which is about 25% slower than tyche-i in JS.
  me.next = function() {
    var a = me.a, b = me.b, c = me.c, d = me.d;
    a = (me.a + me.b | 0) >>> 0;
    d = me.d ^ a; d = d << 16 ^ d >>> 16;
    c = me.c + d | 0;
    b = me.b ^ c; b = b << 12 ^ d >>> 20;
    me.a = a = a + b | 0;
    d = d ^ a; me.d = d = d << 8 ^ d >>> 24;
    me.c = c = c + d | 0;
    b = b ^ c;
    return me.b = (b << 7 ^ b >>> 25);
  }
  */

  me.a = 0;
  me.b = 0;
  me.c = 2654435769 | 0;
  me.d = 1367130551;

  if (seed === Math.floor(seed)) {
    // Integer seed.
    me.a = (seed / 0x100000000) | 0;
    me.b = seed | 0;
  } else {
    // String seed.
    strseed += seed;
  }

  // Mix in string seed, then discard an initial batch of 64 values.
  for (var k = 0; k < strseed.length + 20; k++) {
    me.b ^= strseed.charCodeAt(k) | 0;
    me.next();
  }
}

function copy(f, t) {
  t.a = f.a;
  t.b = f.b;
  t.c = f.c;
  t.d = f.d;
  return t;
};

function impl(seed, opts) {
  var xg = new XorGen(seed),
      state = opts && opts.state,
      prng = function() { return (xg.next() >>> 0) / 0x100000000; };
  prng.double = function() {
    do {
      var top = xg.next() >>> 11,
          bot = (xg.next() >>> 0) / 0x100000000,
          result = (top + bot) / (1 << 21);
    } while (result === 0);
    return result;
  };
  prng.int32 = xg.next;
  prng.quick = prng;
  if (state) {
    if (typeof(state) == 'object') copy(state, xg);
    prng.state = function() { return copy(xg, {}); }
  }
  return prng;
}

if (module && module.exports) {
  module.exports = impl;
} else if (define && define.amd) {
  define(function() { return impl; });
} else {
  this.tychei = impl;
}

})(
  this,
  (typeof module) == 'object' && module,    // present in node.js
  (typeof define) == 'function' && define   // present with an AMD loader
);



},{}],6:[function(require,module,exports){
// A Javascript implementaion of the "xor128" prng algorithm by
// George Marsaglia.  See http://www.jstatsoft.org/v08/i14/paper

(function(global, module, define) {

function XorGen(seed) {
  var me = this, strseed = '';

  me.x = 0;
  me.y = 0;
  me.z = 0;
  me.w = 0;

  // Set up generator function.
  me.next = function() {
    var t = me.x ^ (me.x << 11);
    me.x = me.y;
    me.y = me.z;
    me.z = me.w;
    return me.w ^= (me.w >>> 19) ^ t ^ (t >>> 8);
  };

  if (seed === (seed | 0)) {
    // Integer seed.
    me.x = seed;
  } else {
    // String seed.
    strseed += seed;
  }

  // Mix in string seed, then discard an initial batch of 64 values.
  for (var k = 0; k < strseed.length + 64; k++) {
    me.x ^= strseed.charCodeAt(k) | 0;
    me.next();
  }
}

function copy(f, t) {
  t.x = f.x;
  t.y = f.y;
  t.z = f.z;
  t.w = f.w;
  return t;
}

function impl(seed, opts) {
  var xg = new XorGen(seed),
      state = opts && opts.state,
      prng = function() { return (xg.next() >>> 0) / 0x100000000; };
  prng.double = function() {
    do {
      var top = xg.next() >>> 11,
          bot = (xg.next() >>> 0) / 0x100000000,
          result = (top + bot) / (1 << 21);
    } while (result === 0);
    return result;
  };
  prng.int32 = xg.next;
  prng.quick = prng;
  if (state) {
    if (typeof(state) == 'object') copy(state, xg);
    prng.state = function() { return copy(xg, {}); }
  }
  return prng;
}

if (module && module.exports) {
  module.exports = impl;
} else if (define && define.amd) {
  define(function() { return impl; });
} else {
  this.xor128 = impl;
}

})(
  this,
  (typeof module) == 'object' && module,    // present in node.js
  (typeof define) == 'function' && define   // present with an AMD loader
);



},{}],7:[function(require,module,exports){
// A Javascript implementaion of Richard Brent's Xorgens xor4096 algorithm.
//
// This fast non-cryptographic random number generator is designed for
// use in Monte-Carlo algorithms. It combines a long-period xorshift
// generator with a Weyl generator, and it passes all common batteries
// of stasticial tests for randomness while consuming only a few nanoseconds
// for each prng generated.  For background on the generator, see Brent's
// paper: "Some long-period random number generators using shifts and xors."
// http://arxiv.org/pdf/1004.3115v1.pdf
//
// Usage:
//
// var xor4096 = require('xor4096');
// random = xor4096(1);                        // Seed with int32 or string.
// assert.equal(random(), 0.1520436450538547); // (0, 1) range, 53 bits.
// assert.equal(random.int32(), 1806534897);   // signed int32, 32 bits.
//
// For nonzero numeric keys, this impelementation provides a sequence
// identical to that by Brent's xorgens 3 implementaion in C.  This
// implementation also provides for initalizing the generator with
// string seeds, or for saving and restoring the state of the generator.
//
// On Chrome, this prng benchmarks about 2.1 times slower than
// Javascript's built-in Math.random().

(function(global, module, define) {

function XorGen(seed) {
  var me = this;

  // Set up generator function.
  me.next = function() {
    var w = me.w,
        X = me.X, i = me.i, t, v;
    // Update Weyl generator.
    me.w = w = (w + 0x61c88647) | 0;
    // Update xor generator.
    v = X[(i + 34) & 127];
    t = X[i = ((i + 1) & 127)];
    v ^= v << 13;
    t ^= t << 17;
    v ^= v >>> 15;
    t ^= t >>> 12;
    // Update Xor generator array state.
    v = X[i] = v ^ t;
    me.i = i;
    // Result is the combination.
    return (v + (w ^ (w >>> 16))) | 0;
  };

  function init(me, seed) {
    var t, v, i, j, w, X = [], limit = 128;
    if (seed === (seed | 0)) {
      // Numeric seeds initialize v, which is used to generates X.
      v = seed;
      seed = null;
    } else {
      // String seeds are mixed into v and X one character at a time.
      seed = seed + '\0';
      v = 0;
      limit = Math.max(limit, seed.length);
    }
    // Initialize circular array and weyl value.
    for (i = 0, j = -32; j < limit; ++j) {
      // Put the unicode characters into the array, and shuffle them.
      if (seed) v ^= seed.charCodeAt((j + 32) % seed.length);
      // After 32 shuffles, take v as the starting w value.
      if (j === 0) w = v;
      v ^= v << 10;
      v ^= v >>> 15;
      v ^= v << 4;
      v ^= v >>> 13;
      if (j >= 0) {
        w = (w + 0x61c88647) | 0;     // Weyl.
        t = (X[j & 127] ^= (v + w));  // Combine xor and weyl to init array.
        i = (0 == t) ? i + 1 : 0;     // Count zeroes.
      }
    }
    // We have detected all zeroes; make the key nonzero.
    if (i >= 128) {
      X[(seed && seed.length || 0) & 127] = -1;
    }
    // Run the generator 512 times to further mix the state before using it.
    // Factoring this as a function slows the main generator, so it is just
    // unrolled here.  The weyl generator is not advanced while warming up.
    i = 127;
    for (j = 4 * 128; j > 0; --j) {
      v = X[(i + 34) & 127];
      t = X[i = ((i + 1) & 127)];
      v ^= v << 13;
      t ^= t << 17;
      v ^= v >>> 15;
      t ^= t >>> 12;
      X[i] = v ^ t;
    }
    // Storing state as object members is faster than using closure variables.
    me.w = w;
    me.X = X;
    me.i = i;
  }

  init(me, seed);
}

function copy(f, t) {
  t.i = f.i;
  t.w = f.w;
  t.X = f.X.slice();
  return t;
};

function impl(seed, opts) {
  if (seed == null) seed = +(new Date);
  var xg = new XorGen(seed),
      state = opts && opts.state,
      prng = function() { return (xg.next() >>> 0) / 0x100000000; };
  prng.double = function() {
    do {
      var top = xg.next() >>> 11,
          bot = (xg.next() >>> 0) / 0x100000000,
          result = (top + bot) / (1 << 21);
    } while (result === 0);
    return result;
  };
  prng.int32 = xg.next;
  prng.quick = prng;
  if (state) {
    if (state.X) copy(state, xg);
    prng.state = function() { return copy(xg, {}); }
  }
  return prng;
}

if (module && module.exports) {
  module.exports = impl;
} else if (define && define.amd) {
  define(function() { return impl; });
} else {
  this.xor4096 = impl;
}

})(
  this,                                     // window object or global
  (typeof module) == 'object' && module,    // present in node.js
  (typeof define) == 'function' && define   // present with an AMD loader
);

},{}],8:[function(require,module,exports){
// A Javascript implementaion of the "xorshift7" algorithm by
// François Panneton and Pierre L'ecuyer:
// "On the Xorgshift Random Number Generators"
// http://saluc.engr.uconn.edu/refs/crypto/rng/panneton05onthexorshift.pdf

(function(global, module, define) {

function XorGen(seed) {
  var me = this;

  // Set up generator function.
  me.next = function() {
    // Update xor generator.
    var X = me.x, i = me.i, t, v, w;
    t = X[i]; t ^= (t >>> 7); v = t ^ (t << 24);
    t = X[(i + 1) & 7]; v ^= t ^ (t >>> 10);
    t = X[(i + 3) & 7]; v ^= t ^ (t >>> 3);
    t = X[(i + 4) & 7]; v ^= t ^ (t << 7);
    t = X[(i + 7) & 7]; t = t ^ (t << 13); v ^= t ^ (t << 9);
    X[i] = v;
    me.i = (i + 1) & 7;
    return v;
  };

  function init(me, seed) {
    var j, w, X = [];

    if (seed === (seed | 0)) {
      // Seed state array using a 32-bit integer.
      w = X[0] = seed;
    } else {
      // Seed state using a string.
      seed = '' + seed;
      for (j = 0; j < seed.length; ++j) {
        X[j & 7] = (X[j & 7] << 15) ^
            (seed.charCodeAt(j) + X[(j + 1) & 7] << 13);
      }
    }
    // Enforce an array length of 8, not all zeroes.
    while (X.length < 8) X.push(0);
    for (j = 0; j < 8 && X[j] === 0; ++j);
    if (j == 8) w = X[7] = -1; else w = X[j];

    me.x = X;
    me.i = 0;

    // Discard an initial 256 values.
    for (j = 256; j > 0; --j) {
      me.next();
    }
  }

  init(me, seed);
}

function copy(f, t) {
  t.x = f.x.slice();
  t.i = f.i;
  return t;
}

function impl(seed, opts) {
  if (seed == null) seed = +(new Date);
  var xg = new XorGen(seed),
      state = opts && opts.state,
      prng = function() { return (xg.next() >>> 0) / 0x100000000; };
  prng.double = function() {
    do {
      var top = xg.next() >>> 11,
          bot = (xg.next() >>> 0) / 0x100000000,
          result = (top + bot) / (1 << 21);
    } while (result === 0);
    return result;
  };
  prng.int32 = xg.next;
  prng.quick = prng;
  if (state) {
    if (state.x) copy(state, xg);
    prng.state = function() { return copy(xg, {}); }
  }
  return prng;
}

if (module && module.exports) {
  module.exports = impl;
} else if (define && define.amd) {
  define(function() { return impl; });
} else {
  this.xorshift7 = impl;
}

})(
  this,
  (typeof module) == 'object' && module,    // present in node.js
  (typeof define) == 'function' && define   // present with an AMD loader
);


},{}],9:[function(require,module,exports){
// A Javascript implementaion of the "xorwow" prng algorithm by
// George Marsaglia.  See http://www.jstatsoft.org/v08/i14/paper

(function(global, module, define) {

function XorGen(seed) {
  var me = this, strseed = '';

  // Set up generator function.
  me.next = function() {
    var t = (me.x ^ (me.x >>> 2));
    me.x = me.y; me.y = me.z; me.z = me.w; me.w = me.v;
    return (me.d = (me.d + 362437 | 0)) +
       (me.v = (me.v ^ (me.v << 4)) ^ (t ^ (t << 1))) | 0;
  };

  me.x = 0;
  me.y = 0;
  me.z = 0;
  me.w = 0;
  me.v = 0;

  if (seed === (seed | 0)) {
    // Integer seed.
    me.x = seed;
  } else {
    // String seed.
    strseed += seed;
  }

  // Mix in string seed, then discard an initial batch of 64 values.
  for (var k = 0; k < strseed.length + 64; k++) {
    me.x ^= strseed.charCodeAt(k) | 0;
    if (k == strseed.length) {
      me.d = me.x << 10 ^ me.x >>> 4;
    }
    me.next();
  }
}

function copy(f, t) {
  t.x = f.x;
  t.y = f.y;
  t.z = f.z;
  t.w = f.w;
  t.v = f.v;
  t.d = f.d;
  return t;
}

function impl(seed, opts) {
  var xg = new XorGen(seed),
      state = opts && opts.state,
      prng = function() { return (xg.next() >>> 0) / 0x100000000; };
  prng.double = function() {
    do {
      var top = xg.next() >>> 11,
          bot = (xg.next() >>> 0) / 0x100000000,
          result = (top + bot) / (1 << 21);
    } while (result === 0);
    return result;
  };
  prng.int32 = xg.next;
  prng.quick = prng;
  if (state) {
    if (typeof(state) == 'object') copy(state, xg);
    prng.state = function() { return copy(xg, {}); }
  }
  return prng;
}

if (module && module.exports) {
  module.exports = impl;
} else if (define && define.amd) {
  define(function() { return impl; });
} else {
  this.xorwow = impl;
}

})(
  this,
  (typeof module) == 'object' && module,    // present in node.js
  (typeof define) == 'function' && define   // present with an AMD loader
);



},{}],10:[function(require,module,exports){
/*
Copyright 2014 David Bau.

Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

*/

(function (pool, math) {
//
// The following constants are related to IEEE 754 limits.
//
var global = this,
    width = 256,        // each RC4 output is 0 <= x < 256
    chunks = 6,         // at least six RC4 outputs for each double
    digits = 52,        // there are 52 significant digits in a double
    rngname = 'random', // rngname: name for Math.random and Math.seedrandom
    startdenom = math.pow(width, chunks),
    significance = math.pow(2, digits),
    overflow = significance * 2,
    mask = width - 1,
    nodecrypto;         // node.js crypto module, initialized at the bottom.

//
// seedrandom()
// This is the seedrandom function described above.
//
function seedrandom(seed, options, callback) {
  var key = [];
  options = (options == true) ? { entropy: true } : (options || {});

  // Flatten the seed string or build one from local entropy if needed.
  var shortseed = mixkey(flatten(
    options.entropy ? [seed, tostring(pool)] :
    (seed == null) ? autoseed() : seed, 3), key);

  // Use the seed to initialize an ARC4 generator.
  var arc4 = new ARC4(key);

  // This function returns a random double in [0, 1) that contains
  // randomness in every bit of the mantissa of the IEEE 754 value.
  var prng = function() {
    var n = arc4.g(chunks),             // Start with a numerator n < 2 ^ 48
        d = startdenom,                 //   and denominator d = 2 ^ 48.
        x = 0;                          //   and no 'extra last byte'.
    while (n < significance) {          // Fill up all significant digits by
      n = (n + x) * width;              //   shifting numerator and
      d *= width;                       //   denominator and generating a
      x = arc4.g(1);                    //   new least-significant-byte.
    }
    while (n >= overflow) {             // To avoid rounding up, before adding
      n /= 2;                           //   last byte, shift everything
      d /= 2;                           //   right using integer math until
      x >>>= 1;                         //   we have exactly the desired bits.
    }
    return (n + x) / d;                 // Form the number within [0, 1).
  };

  prng.int32 = function() { return arc4.g(4) | 0; }
  prng.quick = function() { return arc4.g(4) / 0x100000000; }
  prng.double = prng;

  // Mix the randomness into accumulated entropy.
  mixkey(tostring(arc4.S), pool);

  // Calling convention: what to return as a function of prng, seed, is_math.
  return (options.pass || callback ||
      function(prng, seed, is_math_call, state) {
        if (state) {
          // Load the arc4 state from the given state if it has an S array.
          if (state.S) { copy(state, arc4); }
          // Only provide the .state method if requested via options.state.
          prng.state = function() { return copy(arc4, {}); }
        }

        // If called as a method of Math (Math.seedrandom()), mutate
        // Math.random because that is how seedrandom.js has worked since v1.0.
        if (is_math_call) { math[rngname] = prng; return seed; }

        // Otherwise, it is a newer calling convention, so return the
        // prng directly.
        else return prng;
      })(
  prng,
  shortseed,
  'global' in options ? options.global : (this == math),
  options.state);
}
math['seed' + rngname] = seedrandom;

//
// ARC4
//
// An ARC4 implementation.  The constructor takes a key in the form of
// an array of at most (width) integers that should be 0 <= x < (width).
//
// The g(count) method returns a pseudorandom integer that concatenates
// the next (count) outputs from ARC4.  Its return value is a number x
// that is in the range 0 <= x < (width ^ count).
//
function ARC4(key) {
  var t, keylen = key.length,
      me = this, i = 0, j = me.i = me.j = 0, s = me.S = [];

  // The empty key [] is treated as [0].
  if (!keylen) { key = [keylen++]; }

  // Set up S using the standard key scheduling algorithm.
  while (i < width) {
    s[i] = i++;
  }
  for (i = 0; i < width; i++) {
    s[i] = s[j = mask & (j + key[i % keylen] + (t = s[i]))];
    s[j] = t;
  }

  // The "g" method returns the next (count) outputs as one number.
  (me.g = function(count) {
    // Using instance members instead of closure state nearly doubles speed.
    var t, r = 0,
        i = me.i, j = me.j, s = me.S;
    while (count--) {
      t = s[i = mask & (i + 1)];
      r = r * width + s[mask & ((s[i] = s[j = mask & (j + t)]) + (s[j] = t))];
    }
    me.i = i; me.j = j;
    return r;
    // For robust unpredictability, the function call below automatically
    // discards an initial batch of values.  This is called RC4-drop[256].
    // See http://google.com/search?q=rsa+fluhrer+response&btnI
  })(width);
}

//
// copy()
// Copies internal state of ARC4 to or from a plain object.
//
function copy(f, t) {
  t.i = f.i;
  t.j = f.j;
  t.S = f.S.slice();
  return t;
};

//
// flatten()
// Converts an object tree to nested arrays of strings.
//
function flatten(obj, depth) {
  var result = [], typ = (typeof obj), prop;
  if (depth && typ == 'object') {
    for (prop in obj) {
      try { result.push(flatten(obj[prop], depth - 1)); } catch (e) {}
    }
  }
  return (result.length ? result : typ == 'string' ? obj : obj + '\0');
}

//
// mixkey()
// Mixes a string seed into a key that is an array of integers, and
// returns a shortened string seed that is equivalent to the result key.
//
function mixkey(seed, key) {
  var stringseed = seed + '', smear, j = 0;
  while (j < stringseed.length) {
    key[mask & j] =
      mask & ((smear ^= key[mask & j] * 19) + stringseed.charCodeAt(j++));
  }
  return tostring(key);
}

//
// autoseed()
// Returns an object for autoseeding, using window.crypto and Node crypto
// module if available.
//
function autoseed() {
  try {
    var out;
    if (nodecrypto && (out = nodecrypto.randomBytes)) {
      // The use of 'out' to remember randomBytes makes tight minified code.
      out = out(width);
    } else {
      out = new Uint8Array(width);
      (global.crypto || global.msCrypto).getRandomValues(out);
    }
    return tostring(out);
  } catch (e) {
    var browser = global.navigator,
        plugins = browser && browser.plugins;
    return [+new Date, global, plugins, global.screen, tostring(pool)];
  }
}

//
// tostring()
// Converts an array of charcodes to a string
//
function tostring(a) {
  return String.fromCharCode.apply(0, a);
}

//
// When seedrandom.js is loaded, we immediately mix a few bits
// from the built-in RNG into the entropy pool.  Because we do
// not want to interfere with deterministic PRNG state later,
// seedrandom will not call math.random on its own again after
// initialization.
//
mixkey(math.random(), pool);

//
// Nodejs and AMD support: export the implementation as a module using
// either convention.
//
if ((typeof module) == 'object' && module.exports) {
  module.exports = seedrandom;
  // When in node.js, try using crypto package for autoseeding.
  try {
    nodecrypto = require('crypto');
  } catch (ex) {}
} else if ((typeof define) == 'function' && define.amd) {
  define(function() { return seedrandom; });
}

// End anonymous scope, and pass initial values.
})(
  [],     // pool: entropy pool starts empty
  Math    // math: package containing random, pow, and seedrandom
);

},{"crypto":29}],11:[function(require,module,exports){
var bundleFn = arguments[3];
var sources = arguments[4];
var cache = arguments[5];

var stringify = JSON.stringify;

module.exports = function (fn, options) {
    var wkey;
    var cacheKeys = Object.keys(cache);

    for (var i = 0, l = cacheKeys.length; i < l; i++) {
        var key = cacheKeys[i];
        var exp = cache[key].exports;
        // Using babel as a transpiler to use esmodule, the export will always
        // be an object with the default export as a property of it. To ensure
        // the existing api and babel esmodule exports are both supported we
        // check for both
        if (exp === fn || exp && exp.default === fn) {
            wkey = key;
            break;
        }
    }

    if (!wkey) {
        wkey = Math.floor(Math.pow(16, 8) * Math.random()).toString(16);
        var wcache = {};
        for (var i = 0, l = cacheKeys.length; i < l; i++) {
            var key = cacheKeys[i];
            wcache[key] = key;
        }
        sources[wkey] = [
            'function(require,module,exports){' + fn + '(self); }',
            wcache
        ];
    }
    var skey = Math.floor(Math.pow(16, 8) * Math.random()).toString(16);

    var scache = {}; scache[wkey] = wkey;
    sources[skey] = [
        'function(require,module,exports){' +
            // try to call default if defined to also support babel esmodule exports
            'var f = require(' + stringify(wkey) + ');' +
            '(f.default ? f.default : f)(self);' +
        '}',
        scache
    ];

    var workerSources = {};
    resolveSources(skey);

    function resolveSources(key) {
        workerSources[key] = true;

        for (var depPath in sources[key][1]) {
            var depKey = sources[key][1][depPath];
            if (!workerSources[depKey]) {
                resolveSources(depKey);
            }
        }
    }

    var src = '(' + bundleFn + ')({'
        + Object.keys(workerSources).map(function (key) {
            return stringify(key) + ':['
                + sources[key][0]
                + ',' + stringify(sources[key][1]) + ']'
            ;
        }).join(',')
        + '},{},[' + stringify(skey) + '])'
    ;

    var URL = window.URL || window.webkitURL || window.mozURL || window.msURL;

    var blob = new Blob([src], { type: 'text/javascript' });
    if (options && options.bare) { return blob; }
    var workerUrl = URL.createObjectURL(blob);
    var worker = new Worker(workerUrl);
    worker.objectURL = workerUrl;
    return worker;
};

},{}],12:[function(require,module,exports){
var EventEmitter = require('events').EventEmitter
var inherits = require('inherits')
var WebWorkify = require('webworkify')

inherits(Evolve, EventEmitter)
function Evolve (options) {
  var self = this
  self.worker = undefined
}

Evolve.prototype.distribute = function (data) {
  var self = this
  self.worker = new WebWorkify(require('./evolve.worker'))
  self.worker.addEventListener('message', function (ev) {
    // console.log(JSON.stringify(ev.data))
    console.log('worker result score: ' + ev.data.data[0].score)
    self.emit('result', ev.data.data[0].network)
  })

  // data: { networkdata, inputGame, size }
  self.worker.postMessage({
    type: 'init',
    data: data
  }) // send the worker a message
  console.log('worker started at ' + self.worker.objectURL)
}

module.exports = Evolve

},{"./evolve.worker":13,"events":30,"inherits":2,"webworkify":11}],13:[function(require,module,exports){
var NeuralNetwork = require('./neuralnetwork')

// Game Setting
// var XorGame = require('./game/xor/drawing')
// var FlappyBirdGame = require('./game/fbird/drawing')
var DynamicOutputGame = require('./game/dynamicout/worker')
var TetrisGame = require('./game/tetris/worker')

module.exports = function (worker) {
  var ENV_LIST = {
    'dynamicout': DynamicOutputGame,
    // 'xor': XorGame,
    // 'flappybird': FlappyBirdGame,
    'tetris': TetrisGame
  }

  var Evolve = function () {
    var self = this
    self.pool = []
    self.targetGame = null
    self.iterate = 0
    self.matingSeason = 1000
    self.limitSize = 100
    self.selectRate = 0.1
    self.mutateRate = 0.1
    self.interval = undefined
  }

  Evolve.prototype.init = function (options) {
    var self = this
    while (self.pool[0]) { self.pool.pop() }

    self.targetGame = options.inputGame || 'dynamicout'
    self.limitSize = options.size || self.limitSize
    self.matingSeason = options.matingSeason || self.matingSeason
    self.selectRate = options.selectRate || self.selectRate
    self.mutateRate = options.mutateRate || self.mutateRate
    for (var i = 0; i < self.limitSize * 0.1; i++) {
      var obj = {
        neuralNetwork: new NeuralNetwork({}),
        inputGame: new ENV_LIST[self.targetGame]({}),
        score: 0
      }
      if (options.networkdata) obj.neuralNetwork.importAsJSON(options.networkdata)
      self.pool.push(obj)
    }

    if (self.interval) clearTimeout(self.interval)
    function loopInterval () {
      self.loop()
      self.interval = setTimeout(loopInterval, 0)
    }
    loopInterval()
  }

  Evolve.prototype.loop = function () {
    var self = this
    self.iterate++
    // worker.postMessage('iter: ' + self.iterate)

    // process network
    for (var i = 0; i < self.pool.length; i++) {
      self.pool[i].inputGame.gameLoop()
      self.pool[i].neuralNetwork.process(self.pool[i].inputGame.getEnvironmentData())
      self.pool[i].inputGame.pushAction(self.pool[i].neuralNetwork.getOutput())
    }

    // decide population - think it as mating season
    if (self.iterate % self.matingSeason === 0) self.populate()
  }

  Evolve.prototype.populate = function () {
    var self = this
    // calc cost : fitness
    for (var i = 0; i < self.pool.length; i++) {
      var score = self.pool[i].inputGame.getScore()
      self.pool[i].score = score
    }

    // sort
    self.pool.sort(function (a, b) {
      if (a.score > b.score) { return -1 }
      if (a.score < b.score) { return 1 }
      return 0
    })
    // console.log('get score?!' + self.pool[0].score)

    // select
    var selectedNum = Math.floor(self.pool.length * self.selectRate)
    for (var j = 0; j < selectedNum; j++) {
      var tartgetObj = self.pool[Math.floor(Math.random() * self.pool.length * self.selectRate)]
      // crossover
      var newGene = self.pool[j].neuralNetwork.crossover(tartgetObj.neuralNetwork.saveAsJSON())
      var newobj = {
        neuralNetwork: new NeuralNetwork({}),
        inputGame: new ENV_LIST[self.targetGame]({}),
        score: tartgetObj.score
      }
      newobj.neuralNetwork.importAsJSON(newGene)
      // mutate
      newobj.neuralNetwork.mutate(self.mutateRate * 0.5)
      self.pool.unshift(newobj)
      // self.pool.splice(selectedNum, 0, newobj)
    }
    for (var k = j; k < Math.min(self.pool.length, self.limitSize); k++) {
      self.pool[k].neuralNetwork.mutate(self.mutateRate)
      self.pool[k].inputGame.reset()
    }
    for (var l = k; l < self.pool.length; l++) {
      self.pool.pop()
    }

    var genes = []
    for (var m = 0; m < 10; m++) {
      genes.push({
        network: self.pool[m].neuralNetwork.saveAsJSON(),
        score: self.pool[m].score
      })
    }

    var postdata = {
      type: 'update',
      data: genes
    }
    worker.postMessage(postdata)
  }

  Evolve.prototype.onmessage = function (messege) {
    var self = this
    switch (messege.type) {
      case 'init':
        self.init(messege.data)
        break
      default:
        break
    }
  }

  var evolve = new Evolve()

  worker.onmessage = function (e) {
    evolve.onmessage(e.data)
  }
}

},{"./game/dynamicout/worker":15,"./game/tetris/worker":21,"./neuralnetwork":25}],14:[function(require,module,exports){
/* global PIXI */

function Scene (options) { // width, height, container
  var self = this
  self.turn = 0
  self.dataArray = [1]
  self.actArray = [0]
  self.prevSize = { width: options.width || 800, height: options.height || 600 }

  // PIXI renderer setting
  self.renderer = PIXI.autoDetectRenderer(options.width || 800, options.height || 600,
    { antialias: !0, transparent: !0, resolution: 1 })
  self.container = options.container || document.body
  self.container.appendChild(self.renderer.view)

  self.stage = new PIXI.Container()
  self.boardClip = new PIXI.Graphics()
  self.stage.addChild(self.boardClip)
}

Scene.prototype.gameLoop = function (delta) {
  var self = this
  // draw
  self.boardClip.clear()
  for (var i = 0; i < self.actArray.length; i++) {
    var element = self.actArray[i]
    self.boardClip.lineStyle(0, 0xFFFFFF)
    self.boardClip.beginFill(element >= 1 ? 0x70FF0B : 0x444444, 1)
    self.boardClip.drawRect(0, i * 55, 50, 50)
    self.boardClip.endFill()
  }
  self.renderer.render(self.stage)

  if (self.prevSize.width !== self.stage.width || self.prevSize.height !== self.stage.height) {
    self.renderer.resize(self.stage.width, self.stage.height)
    self.container.style.width = self.stage.width + 10 + 'px'
    self.container.style.height = self.stage.height + 10 + 'px'
    self.prevSize.width = self.stage.width
    self.prevSize.height = self.stage.height
    console.log('game resize: ' +
      self.prevSize.width + ' ' + self.stage.width + ' ' + self.prevSize.height + ' ' + self.stage.height)
  }
}

Scene.prototype.getScene = function () {
  var self = this
  return self.stage
}
Scene.prototype.getEnvironmentData = function () {
  var self = this
  return self.dataArray
}
Scene.prototype.pushAction = function (actions) {
  var self = this
  self.actArray = actions
  self.turn = (self.turn + 1) % 4
}

module.exports = Scene

},{}],15:[function(require,module,exports){
function LogicWork (options) { // width, height, container
  var self = this
  self.turn = 0
  self.dataArray = [1]
  self.actArray = [0]
  self.score = 0
}

LogicWork.prototype.gameLoop = function (delta) {
  var self = this
  for (var i = 0; i < self.actArray.length; i++) {
    // var element = self.actArray[i]
  }
}

LogicWork.prototype.getEnvironmentData = function () {
  var self = this
  return self.dataArray
}
LogicWork.prototype.pushAction = function (actions) {
  var self = this
  self.actArray = actions
  self.turn = (self.turn + 1) % 4
}

LogicWork.prototype.getScore = function (actions) {
  var self = this
  return self.score
}

LogicWork.prototype.reset = function (actions) {
  var self = this
  self.turn = 0
  self.dataArray = [1]
  self.actArray = [0]
  self.score = 0
}

module.exports = LogicWork

},{}],16:[function(require,module,exports){
/* global PIXI */
var Container = PIXI.Container
var loader = PIXI.loader
var Sprite = PIXI.Sprite
var Graphics = PIXI.Graphics

var birdAnimationStates = [
  'yellow-bird-1.png',
  'yellow-bird-2.png',
  'yellow-bird-3.png',
  'yellow-bird-2.png'
]
// Constants
var OPEN_SPACE_HEIGHT = 201
var MAX_ROTATION = Math.PI / 2 - 0.2
var MIN_ROTATION = -Math.PI / 10
var DAY_LENGTH = 1000

// board count
var XCOUNT = 10
var YCOUNT = 20

function Scene (options) { // width, height, container
  var self = this
  self.turn = 0
  self.miliSecForTurn = 1000 // 1 second
  self.prevTick = 0
  self.tickForTurn = 0
  self.board = []
  for (var i = 0; i < YCOUNT; i++) {
    self.board.push([])
    for (var j = 0; j < XCOUNT; j++) {
      self.board[i].push(0)
    }
  }
  // self.prevSize = { width: options.width || 800, height: options.height || 600 }

  // PIXI renderer setting
  self.renderer = PIXI.autoDetectRenderer(144, 256,
    { antialias: true, transparent: !0, resolution: 2 })
  self.container = options.container || document.body
  self.container.style.width = '288px'
  self.container.style.height = '512px'
  self.container = options.container || document.body
  self.container.appendChild(self.renderer.view)

  self.xsize = self.renderer.width / XCOUNT / 2
  self.ysize = self.renderer.height / YCOUNT / 2

  self.stage = new Container()
  // self.stage.x = 0
  // self.stage.y = 0

  self.scoreContainer = null
  self.id = null
  self.state = null
  self.gameTime = null
  self.isDay = null

  // Sprites
  self.background = null
  self.darkBackground = null
  self.bird = null
  self.floor = null
  self.gameOver = null
  self.pipes = null

  self.birdAnimationStatesIterator = {
    animationState: -1,
    [Symbol.iterator] () { return this },

    next (bird) {
      if (this.animationState > 2) {
        this.animationState = 0
      } else {
        this.animationState += 1
      }

      if (bird.vy >= 2.5) {
        this.animationState = 1
      }

      return { value: birdAnimationStates[this.animationState], done: false }
    }
  }

  self.lastPipe = null
  self.animationId = null

  loader.add(['/img/fbird/sprites.json']).load(function (loader, resources) {
    console.log('PIXI loading complete ')
    // console.log('PIXI loading complete ' + JSON.stringify(resources))

    // Object which refers to sprites in atlas
    self.id = loader.resources['/img/fbird/sprites.json'].textures
    // console.log(self.id['night-bg.png'])
    self.init()
  })
  loader.onError.add(function () {
    console.log('PIXI loading error ')
  })
  loader.onProgress.add(function () {
    console.log('PIXI loading progress ')
  }) // called once per loaded/errored file
}

Scene.prototype.init = function () {
  var self = this
  self.gameTime = 0
  self.isDay = true
  self.birdAnimationStatesIterator.animationState = -1
  self.PIPE_SEPARATION = self.renderer.width * 1
  self.gameSpeed = 1
  self.currentGapSize = 70
  self.gameScore = 0
  self.pipes = []

  // Adds night background
  self.darkBackground = new Sprite(self.id['night-bg.png'])
  self.stage.addChild(self.darkBackground)

  // Adds day background
  self.background = new Sprite(self.id['day-bg.png'])
  self.stage.addChild(self.background)

  // Adds the floor
  self.floor = new Sprite(self.id['floor.png'])
  self.floor.y = OPEN_SPACE_HEIGHT
  self.stage.addChild(self.floor)

  // Adds bird
  self.bird = new Sprite(self.id[birdAnimationStates[0]])
  self.bird.y = (OPEN_SPACE_HEIGHT / 2) - (self.bird.height / 2) + 10
  self.bird.x = (self.stage.width / 2) - (40)
  self.bird.pivot.set(self.bird.width / 2, self.bird.height / 2)
  // Bird physics properties
  self.bird.vy = 0
  self.bird.ay = 0.12
  self.stage.addChild(self.bird)

  // Adds a pipe
  var pipeContainer = self.generatePipeContainer(OPEN_SPACE_HEIGHT / 2)
  pipeContainer.x = self.renderer.width
  self.pipes.push(pipeContainer)
  self.stage.addChild(pipeContainer)

  // Adds a score container + scores
  self.scoreContainer = new Container()
  var zeroNum = new Sprite(self.id['0.png'])
  self.scoreContainer.x = (self.renderer.width / 4) - ((zeroNum.width / 2) - 1)
  self.scoreContainer.y = OPEN_SPACE_HEIGHT / 10
  self.scoreContainer.addChild(zeroNum)
  self.stage.addChild(self.scoreContainer)

  self.boardClip = new Graphics()
  self.stage.addChild(self.boardClip)

  self.state = 'start'
}

Scene.prototype.gameLoop = function (delta) {
  var self = this
  if (!self.state) return

  // draw
  self.turn = (self.turn + 1) % 3 // frame skip
  if (self.turn === 0) {
    if (!self.go()) {
      self.reset()
    }
  }
  // draw board
  self.board = self.getBoard()
  // console.log(JSON.stringify(self.board))
  self.boardClip.clear()
  for (var i = 0; i < self.board.length; i++) {
    for (var j = 0; j < self.board[i].length; j++) {
      var element = self.board[i][j]
      self.boardClip.lineStyle(0, 0xFFFFFF)
      self.boardClip.beginFill(element > 0 ? 0x70FFFF : 0x444444, 0.2)
      self.boardClip.drawRect(j * self.xsize, i * self.ysize, self.xsize - 1, self.ysize - 1)
      self.boardClip.endFill()
    }
  }

  self.renderer.render(self.stage)
}

function intersects (r1from, r1to, r2from, r2to) {
  return !(r2from.x >= r1to.x || r2to.x <= r1from.x || r2from.y >= r1to.y || r2to.y <= r1from.y)
}

Scene.prototype.getBoard = function () {
  var self = this

  for (var i = 0; i < self.board.length; i++) {
    for (var j = 0; j < self.board[i].length; j++) {
      var boxLeftX = j * self.xsize
      var boxRightX = boxLeftX + self.xsize
      var boxTopY = i * self.ysize
      var boxBottomY = boxTopY + self.ysize
      self.board[i][j] = 0

      var birdRightX = self.bird.x + self.bird.width / 2
      var birdLeftX = self.bird.x - self.bird.width / 2
      var birdTopY = self.bird.y - self.bird.height / 2
      var birdBottomY = self.bird.y + self.bird.height / 2

      if (intersects({ x: boxLeftX, y: boxTopY },
        { x: boxRightX, y: boxBottomY },
        { x: birdLeftX, y: birdTopY },
        { x: birdRightX, y: birdBottomY })) {
        self.board[i][j] = 1
      }

      self.pipes.forEach(function (pipe) {
        // Between pipe space in X
        if (boxRightX > pipe.x + 5 && boxLeftX < pipe.x + pipe.width - 5) {
          var upPipe = pipe.children[0]
          var downPipe = pipe.children[1]

          if (boxTopY < downPipe.getGlobalPosition().y - self.currentGapSize - 5 ||
            boxBottomY > upPipe.getGlobalPosition().y + upPipe.height + self.currentGapSize + 5) {
            self.board[i][j] = 1
          }
        }
      })
    }
  }
  return self.board
}

Scene.prototype.go = function () {
  var self = this

  // Add time
  self.gameTime += 1

  // Animate the bird
  self.animateBirdPlay()

  // Animate the floor
  self.animateGround(self.gameSpeed)

  // Generate some pipes
  self.generatePipes()

  // Animate pipes
  self.animatePipes(self.gameSpeed)

  // Check for collisions
  if (self.checkCollisions() === true) {
    self.bird.vy = 0
    return false
  }

  // Make gaps smaller
  if (self.currentGapSize > 48) {
    self.currentGapSize -= 0.01
  }
  // Make pipes closer together
  if (self.PIPE_SEPARATION > self.renderer.width * 0.35) {
    self.PIPE_SEPARATION -= 0.075
  }
  // Speed up the ground
  if (self.gameSpeed < 1.3) {
    self.gameSpeed += 0.0002
  }

  if (self.gameTime % DAY_LENGTH === DAY_LENGTH - 1) {
    self.isDay = !self.isDay
  }

  if (self.isDay) {
    if (self.background.alpha < 1) {
      self.background.alpha += 0.005
    }
  }

  if (!self.isDay) {
    if (self.background.alpha > 0) {
      self.background.alpha -= 0.005
    }
  }

  self.calculateAndSetScore()

  self.displayScore(self.gameScore)
  return true
}
Scene.prototype.reset = function () {
  var self = this
  self.stage.removeChildren()

  self.init()
}
Scene.prototype.getEnvironmentData = function () {
  var self = this
  // serialize and desaturate
  var serialdata = []
  for (var i = 0; i < self.board.length; i++) {
    for (var j = 0; j < self.board[i].length; j++) {
      serialdata.push((self.board[i][j] === 0) ? 0 : 1)
    }
  }
  return serialdata
}

Scene.prototype.pushAction = function (actions) {
  var self = this
  // left, right, down, rotate, none
  if (actions[0]) {
    self.bird.vy = -2.75
  }
}

Scene.prototype.calculateAndSetScore = function (deletedLineNum) {
  var self = this
  self.pipes.forEach(function (pipe) {
    if (pipe !== self.lastPipe && (Math.abs(pipe.x + pipe.width) - (self.bird.x + (self.bird.width / 2))) < 1) {
      self.lastPipe = pipe
      self.gameScore += 1
    }
  })
}

Scene.prototype.animateBirdPlay = function () {
  var self = this
  // Animate the bird's vertical position
  self.bird.vy += self.bird.ay
  self.bird.y += self.bird.vy

  // Animate the bird's rotation
  if (self.bird.vy > 0 && self.bird.rotation < MAX_ROTATION) {
    self.bird.rotation += 0.04 * self.bird.vy
  } else if (self.bird.vy < 0 && self.bird.rotation > MIN_ROTATION) {
    self.bird.rotation -= 0.4
  }

  // Check if the bird has collided with the ceiling
  if (self.bird.y - (self.bird.height / 2) < 0) {
    self.bird.y = self.bird.height / 2
    self.bird.vy = 0
  }
}

Scene.prototype.animateGround = function (speed) {
  var self = this
  self.floor.x -= speed

  if (self.floor.x < -23.5) {
    self.floor.x = 0
  }
}

Scene.prototype.generatePipes = function () {
  var self = this
  if (self.pipes[0].x < -(self.id['down-green-pipe.png'].width)) {
    self.pipes.splice(0, 1)
    return
  }

  var stopGeneratingAt = self.renderer.width * 2
  var centerPoint = Math.random() * ((OPEN_SPACE_HEIGHT - self.currentGapSize) - (self.currentGapSize)) + self.currentGapSize
  var currentPosition = self.pipes.slice(-1)[0].x + self.PIPE_SEPARATION

  while (currentPosition < stopGeneratingAt) {
    var pipeContainer = self.generatePipeContainer(centerPoint, currentPosition)
    pipeContainer.x = currentPosition

    self.pipes.push(pipeContainer)
    self.stage.addChild(pipeContainer)
    // Move the floor to the front
    self.stage.setChildIndex(self.floor, self.stage.children.length - 1)

    currentPosition += self.PIPE_SEPARATION
  }
}

Scene.prototype.generatePipeContainer = function (center) {
  var self = this
  var pipeContainer = new Container()
  var upPipe = new Sprite(self.id['up-green-pipe.png'])
  var downPipe = new Sprite(self.id['down-green-pipe.png'])

  upPipe.x = 0
  upPipe.y = center - (self.currentGapSize / 2) - upPipe.height
  upPipe.vx = -self.gameSpeed
  downPipe.x = 0
  downPipe.y = center + (self.currentGapSize / 2)
  downPipe.vx = -self.gameSpeed
  pipeContainer.addChild(upPipe)
  pipeContainer.addChild(downPipe)

  return pipeContainer
}

Scene.prototype.animatePipes = function (speed) {
  var self = this
  self.pipes.forEach((pipe) => {
    pipe.x -= speed
  })
}

Scene.prototype.checkCollisions = function () {
  var self = this
  var collided = false

  // Check if the bird has collided with the ground
  if (self.bird.y + (self.bird.height / 2) > OPEN_SPACE_HEIGHT) {
    // YOU LOST!!
    self.bird.y = OPEN_SPACE_HEIGHT - (self.bird.height / 2)
    collided = true
  }

  // Check if the bird has collided with a pipe
  var birdRightX = self.bird.x + self.bird.width / 2
  var birdLeftX = self.bird.x - self.bird.width / 2
  var birdTopY = self.bird.y - self.bird.height / 2
  var birdBottomY = self.bird.y + self.bird.height / 2

  self.pipes.forEach(function (pipe) {
    // Between pipe space in X
    if (birdRightX > pipe.x + 5 && birdLeftX < pipe.x + pipe.width - 5) {
      var upPipe = pipe.children[0]
      var downPipe = pipe.children[1]

      if (birdTopY < downPipe.getGlobalPosition().y - self.currentGapSize - 5 ||
        birdBottomY > upPipe.getGlobalPosition().y + upPipe.height + self.currentGapSize + 5) {
        collided = true
      }
    }
  })

  return collided
}

Scene.prototype.displayScore = function (score) {
  var self = this
  const digits = String(score)
    .split('')
    .map(d => `${d}.png`)

  self.scoreContainer.removeChildren()

  digits.forEach((digit) => {
    const sprite = new Sprite(self.id[digit])
    let lastChildWidth = 0
    let lastChildX = 0

    if (self.scoreContainer.children.length > 0) {
      const lastChild = self.scoreContainer.getChildAt(self.scoreContainer.children.length - 1)
      lastChildWidth = lastChild.width
      lastChildX = lastChild.x
    }

    sprite.x = lastChildX + lastChildWidth + 1
    self.scoreContainer.addChild(sprite)
    self.stage.setChildIndex(self.scoreContainer, self.stage.children.length - 1)
  })

  // Center the scoreContainer
  self.scoreContainer.x = (self.renderer.width / 4) - (self.scoreContainer.width / 2)
}

module.exports = Scene

},{}],17:[function(require,module,exports){
/* global PIXI */
var TetrisGame = require('./gamelogic.js')

function Scene (options) { // width, height, container
  var self = this
  self.turn = 0
  self.miliSecForTurn = 1000 // 1 second
  self.prevTick = 0
  self.tickForTurn = 0
  self.gameLogic = new TetrisGame({})
  self.board = self.gameLogic.getBoard()
  self.prevSize = { width: options.width || 800, height: options.height || 600 }

  // PIXI renderer setting
  self.renderer = PIXI.autoDetectRenderer(140, 140,
    { antialias: !0, transparent: !0, resolution: 1 })
  self.container = options.container || document.body
  self.container.style.width = '140px'
  self.container.style.height = '140px'
  self.container = options.container || document.body
  self.container.appendChild(self.renderer.view)

  self.stage = new PIXI.Container()
  self.stage.x = 10
  self.stage.y = 10
  self.boardClip = new PIXI.Graphics()
  self.stage.addChild(self.boardClip)
}

Scene.prototype.gameLoop = function (delta) {
  var self = this
  // draw
  self.turn = (self.turn + 1) % 12 // frame skip
  if (self.turn === 0) {
    if (!self.gameLogic.go()) {
      self.gameLogic.reset()
    }
  }
  // draw board
  self.board = self.gameLogic.getBoard()
  // console.log(JSON.stringify(self.board))
  self.boardClip.clear()
  for (var i = 0; i < self.board.length; i++) {
    for (var j = 0; j < self.board[i].length; j++) {
      var element = self.board[i][j]
      self.boardClip.lineStyle(0, 0xFFFFFF)
      self.boardClip.beginFill(element > 0 ? 0x70FF0B : 0x444444, 1)
      self.boardClip.drawRect(j * 25, i * 25, 20, 20)
      self.boardClip.endFill()
    }
  }
  self.renderer.render(self.stage)
}

// Scene.prototype.getScene = function () {
//   var self = this
//   return self.stage
// }
Scene.prototype.getEnvironmentData = function () {
  var self = this
  // serialize and desaturate
  var serialdata = []
  for (var i = 0; i < self.board.length; i++) {
    for (var j = 0; j < self.board[i].length; j++) {
      serialdata.push((self.board[i][j] === 0) ? 0 : 1)
    }
  }
  return serialdata
}
Scene.prototype.pushAction = function (actions) {
  var self = this
  // left, right, down, rotate, none
  if (actions[0]) self.gameLogic.doAction('left')
  if (actions[1]) self.gameLogic.doAction('right')
  if (actions[2]) self.gameLogic.doAction('rotate')
  if (actions[3]) self.gameLogic.doAction('down')
}

module.exports = Scene

},{"./gamelogic.js":18}],18:[function(require,module,exports){
var global = require('./global')
var Shape = require('./shape')
var EventEmitter = require('events').EventEmitter
var inherits = require('inherits')

inherits(TetrisGame, EventEmitter)

/* 전체적으로 게임을 진행시키기 위한 데이터와 메소드를 담고있는 객체 */
function TetrisGame (options) {
  var self = this
  if (!(self instanceof TetrisGame)) return new TetrisGame(options)

  self.id = options.clientId || 'offline'
  self.roomId = options.roomId || 'offline'
  self.order = options.order || 1

  self.history = []
  self.sequenceNumber = 0
    // 클라이언트에서만 사용하는 배열
  self.pendingInputs = []
  self.messages = []
    // 서버에서만 사용하는 배열
  self.processedInputs = []

    // key flags
  self.key_right = false
  self.key_left = false
  self.key_up = false
  self.key_down = false
  self.key_shift = false
  self.key_a = false
  self.key_s = false
  self.key_space = false

  self.isGameOver = false
  self.isPause = false
  self.holdable = true

  self.block = new Shape(options.randomSeed || 'some random seed')

  self.startX = 0
  self.score = 0

  self.board = []

  for (var i = 0; i < global.BOARD_HEIGHT; i++) {
    self.board[i] = []
    for (var j = 0; j < global.BOARD_WIDTH; j++) {
      self.board[i][j] = 0
    }
  }
}

TetrisGame.prototype.doAction = function (input) {
  var self = this
  var validate = false
  switch (input) {
    case 'left':
      validate = self.move(0, -1, self.block.currentBlock.array)
      break
    case 'right':
      validate = self.move(0, 1, self.block.currentBlock.array)
      break
    case 'down':
      validate = self.move(1, 0, self.block.currentBlock.array)
      break
    case 'rotate':
      validate = self.rotate('right')
      break
  }
  if (!validate) {
    // console.log('do nothing')
  }
}

/*
TetrisGame.prototype.pushHistory = function (time, seed, type, message) {
    var self = this;
    self.randomSeed = seed;
    // push action to history log
    self.history.push({ time: time, owner: self.id, seed: seed, type: type, message: message })
};
*/
/* interval 함수의 인자로 쓰일 함수이다. 시간 간격 이후에 할 일을 정의한다.
1. 현재 Gameover 상태인지 체크한다.
2. 현재 블록이 내려갔을때 겹치는지 체크한다.
  2-1. 겹치면 블록을 현재 위치에 적용시킨다
  2-2. 블록이 한 줄 다 채워졌는지 체크하여 지운다.
  2-3. 만약 새로나올 블록의 위치에 어떤 블록이 나오면 Gameover 상태로 바꾼다.
  2-4. 그게 아니라면 다음 블록을 내보낸다.

3.  겹치지 않는다면 블록을 한 칸 내린다.
*/

TetrisGame.prototype.go = function () {
  var self = this

  if (self.getisGameover()) {
    return false
  }

  if (self.intersectCheck(self.block.Y + 1, self.block.X, self.block.currentBlock.array)) {
    self.board = self.applyCurrentBlockToBoard(self.block.Y, self.block.X)

    self.deleteLine()
    self.holdable = true

    if (self.intersectCheck(0, 0, self.block.nextBlock.array)) {
      self.setIsGameover(true)
    } else {
      self.block.changeCurrentToNext()
    }
  } else {
    self.block.goDown()
  }
  // console.log(JSON.stringify(self.board))
  return true
}

TetrisGame.prototype.reset = function () {
  var self = this
  self.board = []
  for (var i = 0; i < global.BOARD_HEIGHT; i++) {
    self.board[i] = []
    for (var j = 0; j < global.BOARD_WIDTH; j++) {
      self.board[i][j] = 0
    }
  }
  self.setIsGameover(false)
  // self.block.changeCurrentToNext()
}

TetrisGame.prototype.calculateAndSetScore = function (deletedLineNum) {
  var self = this

  self.score += deletedLineNum * deletedLineNum * 10
}

TetrisGame.prototype.intersectCheck = function (y, x, block) {
  var self = this
  var board = self.board

  for (var i = 0; i < 4; i++) {
    for (var j = 0; j < 4; j++) {
      if (block[i][j]) {
        if (i + y >= global.BOARD_HEIGHT || j + x >= global.BOARD_WIDTH || j + x < 0 || board[y + i][x + j]) {
          return true
                    /* 움직였을 때 어떤 물체 또는 board 끝에 겹침을 뜻함 */
        }
      }
    }
  }
  return false
}

TetrisGame.prototype.applyCurrentBlockToBoard = function (y, x) {
  var self = this
  var board = self.board
  var block = self.block.currentBlock.array

  var newBoard = []

  for (var i = 0; i < global.BOARD_HEIGHT; i++) {
    newBoard[i] = board[i].slice()
  }

  for (var i = 0; i < 4; i++) {
    for (var j = 0; j < 4; j++) {
      if (block[i][j]) {
        newBoard[i + y][j + x] = block[i][j]
      }
    }
  }
  return newBoard
}

TetrisGame.prototype.deleteLine = function () {
  var self = this
  var board = self.board

  var newBoard = []
  var count = global.BOARD_HEIGHT
  for (var i = global.BOARD_HEIGHT; i-- > 0;) {
    for (var j = 0; j < global.BOARD_WIDTH; j++) {
      if (!board[i][j]) {
                /* 0인 성분이 있으면 한줄이 다 안 채워진 것이므로 붙여넣기 해 준다. */
                /* --count로 아래부터 새로운 board를 채워주는 이유는 맨 아래줄부터 1로 채워진 줄이 있다면 자동적으로
                새로운 board에는 추가되지 않기 때문이다. 이 이후에 맨위부터 count까지는 0으로 채워 주어야 한다. */
        newBoard[--count] = board[i].slice()
        break
      }
    }
  }

  for (var i = 0; i < count; i++) {
    newBoard[i] = []
    for (var j = 0; j < global.BOARD_WIDTH; j++) {
      newBoard[i][j] = 0
    }
  }

  self.board = newBoard
  self.calculateAndSetScore(count)
}

TetrisGame.prototype.move = function (dy, dx, inputBlock) {
  var self = this

  if (!self.intersectCheck(self.block.Y + dy, self.block.X + dx, inputBlock)) {
    self.block.X += dx
    self.block.Y += dy
    return true
  }
  return false
}

TetrisGame.prototype.rotate = function (direction) {
  var self = this

  var newBlock

  if (direction === 'left') {
    newBlock = self.block.rotateLeft()
  } else if (direction === 'right') {
    newBlock = self.block.rotateRight()
  }

  if (!self.intersectCheck(self.block.Y, self.block.X, newBlock)) {
    self.block.setCurrentBlock(newBlock)
    return true
  }
  return false
}

TetrisGame.prototype.letFall = function () {
  var self = this
  var deltaY = 0
  while (self.move(1, 0, self.block.currentBlock.array)) {
    deltaY++
  }
  self.go()

  return deltaY
}

TetrisGame.prototype.hold = function () {
  var self = this

  if (!self.holdable) return false

  self.holdable = false
  self.block.hold()

  return true
}

TetrisGame.prototype.getId = function () {
  var self = this

  return self.id
}

TetrisGame.prototype.getStartX = function () {
  var self = this

  return self.startX
}

TetrisGame.prototype.getOrder = function () {
  var self = this
  return self.order
}

TetrisGame.prototype.getBlockX = function () {
  var self = this

  return self.block.X
}

TetrisGame.prototype.getBlockY = function () {
  var self = this

  return self.block.Y
}

TetrisGame.prototype.getisGameover = function () {
  var self = this

  return self.isGameOver
}

TetrisGame.prototype.getisPause = function () {
  var self = this

  return self.isPause
}

TetrisGame.prototype.setIsGameover = function (bool) {
  var self = this

  self.isGameOver = bool
}

TetrisGame.prototype.getScore = function () {
  var self = this

  return self.score
}
TetrisGame.prototype.getCurrentBlock = function () {
  var self = this

  return self.block.currentBlock.array
}

TetrisGame.prototype.getNextBlock = function () {
  var self = this

  return self.block.nextBlock.array
}

TetrisGame.prototype.getHoldBlock = function () {
  var self = this

  return self.block.holdBlock.array
}

TetrisGame.prototype.getHoldable = function () {
  var self = this

  return self.holdable
}

TetrisGame.prototype.getBoard = function () {
  var self = this

  return self.applyCurrentBlockToBoard(self.block.Y, self.block.X)
}

TetrisGame.prototype.getGameData = function () {
  var self = this
    /*
    return {
        id: self.id,
        startX: self.startX,
        isGameOver: self.getisGameover(),
        isPause: self.getisPause(),
        holdable: self.getHoldable(),
        score: self.getScore(),
        X: self.block.X,
        Y: self.block.Y,
        currentBlock: self.getCurrentBlock(),
        nextBlock: self.getNextBlock(),
        holdBlock: self.getHoldBlock(),
        board: self.getBoard()
    };
    */
}

module.exports = TetrisGame

},{"./global":19,"./shape":20,"events":30,"inherits":2}],19:[function(require,module,exports){
module.exports = {
  // host: '127.0.0.1',
  // port: 3000,
  BOARD_WIDTH: 5,
  BOARD_HEIGHT: 5,
  // BLOCK_WIDTH: 30,
  // BLOCK_HEIGHT: 30,
  // FALLING_TIME: 400,
  // KEY_SPACE: 32,
  KEY_SHIFT: 16
}

},{}],20:[function(require,module,exports){
var SeedRandom = require('seedrandom')

function Shape (randomSeed) {
  var self = this

  if (!(self instanceof Shape)) return new Shape(randomSeed)

  self.BLOCKS = [
    [
        [0, 12, 12, 0],
        [0, 0, 12, 0],
        [0, 0, 0, 0],
        [0, 0, 0, 0]
    ],
    [
      [0, 11, 11, 0],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [0, 0, 0, 0]
    ]
    // [
    //     [0, 0, 0, 0],
    //     [0, 11, 11, 0],
    //     [0, 11, 11, 0],
    //     [0, 0, 0, 0]
    // ],
    // [
    //     [0, 0, 12, 0],
    //     [0, 0, 12, 0],
    //     [0, 0, 12, 0],
    //     [0, 0, 12, 0]
    // ],
    // [
    //     [0, 0, 0, 0],
    //     [0, 13, 13, 0],
    //     [0, 0, 13, 13],
    //     [0, 0, 0, 0]
    // ],
    // [
    //     [0, 0, 0, 0],
    //     [0, 0, 14, 14],
    //     [0, 14, 14, 0],
    //     [0, 0, 0, 0]
    // ],
    // [
    //     [0, 0, 15, 0],
    //     [0, 15, 15, 0],
    //     [0, 0, 15, 0],
    //     [0, 0, 0, 0]
    // ],
    // [
    //     [0, 16, 0, 0],
    //     [0, 16, 0, 0],
    //     [0, 16, 16, 0],
    //     [0, 0, 0, 0]
    // ],
    // [
    //     [0, 0, 17, 0],
    //     [0, 0, 17, 0],
    //     [0, 17, 17, 0],
    //     [0, 0, 0, 0]
    // ]
  ]

  self.randomSeed = randomSeed || Date.now()
  self.random = SeedRandom(self.randomSeed)

  self.X = 0
  self.Y = 0

  self.currentBlock = self.randomBlock()
  self.nextBlock = self.randomBlock()

  self.holdBlock = {
    array: [
        [0, 0, 0, 0],
        [0, 0, 0, 0],
        [0, 0, 0, 0],
        [0, 0, 0, 0]
    ],

    type: -1
  }
}

Shape.prototype.setCurrentBlock = function (array) {
  var self = this
  self.currentBlock.array = array
}

Shape.prototype.hold = function () {
  var self = this
    /* hold블록이 비어있으면 currentBlock에 nextblock을 넣어줘야 한다. */

  if (self.holdBlock.type === -1) {
    self.holdBlock = self.currentBlock
    self.currentBlock = self.nextBlock
    self.nextBlock = self.randomBlock()
  } else {
    var temp = self.holdBlock
    self.holdBlock = self.currentBlock
    self.currentBlock = temp
  }

  self.X = 3
  self.Y = 0
}

Shape.prototype.changeCurrentToNext = function () {
  var self = this

  self.currentBlock = self.nextBlock
  self.nextBlock = self.randomBlock()

  self.X = 0
  self.Y = 0
}

Shape.prototype.goDown = function () {
  var self = this

  self.Y++
}

Shape.prototype.randomBlock = function () {
  var self = this
  var index = Math.floor(self.random() * self.BLOCKS.length)

  return {
    array: self.BLOCKS[index],
    type: index
  }
}

Shape.prototype.rotateRight = function () {
  var self = this
  var block = self.currentBlock.array

  return [
    [block[3][0], block[2][0], block[1][0], block[0][0]],
    [block[3][1], block[2][1], block[1][1], block[0][1]],
    [block[3][2], block[2][2], block[1][2], block[0][2]],
    [block[3][3], block[2][3], block[1][3], block[0][3]]
  ]
}

Shape.prototype.rotateLeft = function () {
  var self = this
  var block = self.currentBlock.array

  return [
    [block[0][3], block[1][3], block[2][3], block[3][3]],
    [block[0][2], block[1][2], block[2][2], block[3][2]],
    [block[0][1], block[1][1], block[2][1], block[3][1]],
    [block[0][0], block[1][0], block[2][0], block[3][0]]
  ]
}

module.exports = Shape

},{"seedrandom":3}],21:[function(require,module,exports){
var TetrisGame = require('./gamelogic.js')

function LogicWork (options) { // width, height, container
  var self = this
  self.turn = 0
  self.miliSecForTurn = 1000 // 1 second
  self.prevTick = 0
  self.tickForTurn = 0
  self.gameLogic = new TetrisGame({})
  self.board = self.gameLogic.getBoard()
}

LogicWork.prototype.gameLoop = function (delta) {
  var self = this
  // draw
  self.turn = (self.turn + 1) % 12 // frame skip
  if (self.turn === 0) {
    if (!self.gameLogic.go()) {
      self.gameLogic.reset()
    }
  }
  // draw board
  self.board = self.gameLogic.getBoard()
}

LogicWork.prototype.getEnvironmentData = function () {
  var self = this
  // serialize and desaturate
  var serialdata = []
  for (var i = 0; i < self.board.length; i++) {
    for (var j = 0; j < self.board[i].length; j++) {
      serialdata.push((self.board[i][j] === 0) ? 0 : 1)
    }
  }
  return serialdata
}

LogicWork.prototype.pushAction = function (actions) {
  var self = this
  // left, right, down, rotate, none
  if (actions[0]) self.gameLogic.doAction('left')
  if (actions[1]) self.gameLogic.doAction('right')
  if (actions[2]) self.gameLogic.doAction('rotate')
  if (actions[3]) self.gameLogic.doAction('down')
}

LogicWork.prototype.getScore = function (actions) {
  var self = this
  return self.gameLogic.getScore()
}

LogicWork.prototype.reset = function (actions) {
  var self = this
  self.gameLogic.reset()
  self.gameLogic.score = 0
}

module.exports = LogicWork

},{"./gamelogic.js":18}],22:[function(require,module,exports){
/* global PIXI */

function Scene (options) { // width, height, container
  var self = this
  self.turn = 0
  self.miliSecForTurn = 1000 // 1 second
  self.dataArray = [
    [0, 0],
    [1, 0],
    [0, 1],
    [1, 1]
  ]
  self.actArray = [0, 0, 0, 0]

  // PIXI renderer setting
  self.renderer = PIXI.autoDetectRenderer(170, 230,
    { antialias: !0, transparent: !0, resolution: 1 })
  self.container = options.container || document.body
  self.container.style.width = '170px'
  self.container.style.height = '230px'
  self.container.appendChild(self.renderer.view)

  self.stage = new PIXI.Container()
  self.boardClip = new PIXI.Graphics()
  for (var i = 0; i < self.dataArray.length; i++) {
    var element = self.dataArray[i]
    self.boardClip.lineStyle(0, 0xFFFFFF)
    self.boardClip.beginFill(element[0] === 1 ? 0xFF700B : 0x444444, 1)
    self.boardClip.drawRect(0, i * 55, 50, 50)
    self.boardClip.endFill()
    self.boardClip.beginFill(element[1] === 1 ? 0xFF700B : 0x444444, 1)
    self.boardClip.drawRect(55, i * 55, 50, 50)
    self.boardClip.endFill()
  }
  self.ansClip = new PIXI.Graphics()
  self.ansClip.x = 110
  self.stage.addChild(self.boardClip)
  self.stage.addChild(self.ansClip)
}

Scene.prototype.gameLoop = function (delta) {
  var self = this
  // draw
  self.ansClip.clear()
  for (var i = 0; i < self.actArray.length; i++) {
    var element = self.actArray[i]
    self.ansClip.lineStyle(0, 0xFFFFFF)
    self.ansClip.beginFill(element >= 1 ? 0x70FF0B : 0x444444, 1)
    self.ansClip.drawRect(0, i * 55, 50, 50)
    self.ansClip.endFill()
  }
  self.renderer.render(self.stage)
}

Scene.prototype.getScene = function () {
  var self = this
  return self.stage
}
Scene.prototype.getEnvironmentData = function () {
  var self = this
  return self.dataArray[self.turn]
}
Scene.prototype.pushAction = function (actions) {
  var self = this
  self.actArray[self.turn] = actions[0]
  self.turn = (self.turn + 1) % 4
}

module.exports = Scene

},{}],23:[function(require,module,exports){
// expected hue range: [0, 360)
// expected saturation range: [0, 1]
// expected lightness range: [0, 1]
var hslToRgb = function (hue, saturation, lightness) {
  // based on algorithm from http://en.wikipedia.org/wiki/HSL_and_HSV#Converting_to_RGB
  if (hue === undefined) {
    return [0, 0, 0]
  }

  var chroma = (1 - Math.abs((2 * lightness) - 1)) * saturation
  var huePrime = hue / 60
  var secondComponent = chroma * (1 - Math.abs((huePrime % 2) - 1))

  huePrime = Math.floor(huePrime)
  var red
  var green
  var blue

  if (huePrime === 0) {
    red = chroma
    green = secondComponent
    blue = 0
  } else if (huePrime === 1) {
    red = secondComponent
    green = chroma
    blue = 0
  } else if (huePrime === 2) {
    red = 0
    green = chroma
    blue = secondComponent
  } else if (huePrime === 3) {
    red = 0
    green = secondComponent
    blue = chroma
  } else if (huePrime === 4) {
    red = secondComponent
    green = 0
    blue = chroma
  } else if (huePrime === 5) {
    red = chroma
    green = 0
    blue = secondComponent
  }

  var lightnessAdjustment = lightness - (chroma / 2)
  red += lightnessAdjustment
  green += lightnessAdjustment
  blue += lightnessAdjustment

  return [Math.round(red * 255), Math.round(green * 255), Math.round(blue * 255)]
}

// Typically all dependencies should be declared at the top of the file.

// Now let's define an API for our module, we're taking hue, saturation and luminosity values and outputting a CSS compatible hex string.
// Hue is in degrees, between 0 and 359. Since degrees a cyclical in nature, we'll support numbers greater than 359 or less than 0 by "spinning" them around until they fall within the 0 to 359 range.
// Saturation and luminosity are both percentages, we'll represent these percentages with whole numbers between 0 and 100. For these numbers we'll need to enforce a maximum and a minimum, anything below 0 will become 0, anything above 100 will become 100.
// Let's write some utility functions to handle this logic:

function max (val, n) {
  return (val > n) ? n : val
}

function min (val, n) {
  return (val < n) ? n : val
}

function cycle (val) {
  // for safety:
  val = max(val, 1e7)
  val = min(val, -1e7)
  // cycle value:
  while (val < 0) { val += 360 }
  while (val > 359) { val -= 360 }
  return val
}

// Now for the main piece, the `hsl` function:

function hsl (hue, saturation, luminosity, headString) {
  // resolve degrees to 0 - 359 range
  hue = cycle(hue)

  // enforce constraints
  saturation = min(max(saturation, 100), 0)
  luminosity = min(max(luminosity, 100), 0)

  // convert to 0 to 1 range used by hsl-to-rgb-for-reals
  saturation /= 100
  luminosity /= 100

  // let hsl-to-rgb-for-reals do the hard work
  var rgb = hslToRgb(hue, saturation, luminosity)

  // convert each value in the returned RGB array
  // to a 2 character hex value, join the array into
  // a string, prefixed with a hash
  var hexcolor = rgb
    .map(function (n) {
      return (256 + n).toString(16).substr(-2)
    })
    .join('')

  return headString + hexcolor.toUpperCase()
}

// In order to make our code into a bona fide module we have to export it:

module.exports = hsl

},{}],24:[function(require,module,exports){
var NeuroCanvas = require('./neurocanvas')
var NeuroPanel = require('./neurocontrol')
var NeuralNetwork = require('./neuralnetwork')
var Evolve = require('./evolve')

function NeuroEditor (options) {
  var self = this
  options = options || {}
  self.title = options.title || 'no name'
  self.container = options.container || document.createElement('div')
  self.container.className = 'editor-view'
  self.bindedTab = null

  var dom = options.textarea
  if (!dom) {
    dom = document.createElement('div')
    dom.className = 'view neuro-editor'
    self.container.appendChild(dom)
  }
  self.dom = dom

  self.neuralNetwork = null
  self.neuroCanvas = null
  self.neuroPanel = null
}

NeuroEditor.prototype.open = function () {
  var self = this

  self.neuralNetwork = new NeuralNetwork({ contentID: null })
  // self.neuralNetwork.on('changeNode', function (data) {
  //   self.emit('changeNode', data)
  // })
  // self.neuralNetwork.on('changeLink', function (data) {
  //   self.emit('changeLink', data)
  // })

  var canvasview = document.createElement('div')
  canvasview.className = 'neuro-editor-canvas'
  var neurogamedom = document.createElement('div')
  neurogamedom.className = 'neuro-editor-game'
  var neuropaneldom = document.createElement('div')
  neuropaneldom.className = 'neuro-editor-panel'
  self.dom.appendChild(canvasview)
  self.dom.appendChild(neurogamedom)
  self.dom.appendChild(neuropaneldom)

  self.neuroPanel = new NeuroPanel({
    container: neuropaneldom,
    neuralNetwork: self.neuralNetwork,
    inputGameDom: neurogamedom
  })
  self.neuroCanvas = new NeuroCanvas({
    width: canvasview.clientWidth,
    height: canvasview.clientHeight,
    container: canvasview,
    neuroPanel: self.neuroPanel,
    neuralNetwork: self.neuralNetwork
  })

  self.neuroCanvas.on('neuronSelected', self.neuroPanel.selectNeuron.bind(self.neuroPanel))

  self.neuroCanvas.initCanvas()

  self.neuroPanel.initPanel()

  window.NeuralNetwork = self.neuralNetwork

  var testnet = require('../data/tetris180502.json')
  // var testnet = require('../data/tetris180531.json')
  // var testnet = require('../data/d.json')
  self.evolve = new Evolve({})
  self.evolve.distribute({
    networkdata: testnet,
    inputGame: 'tetris',
    size: 1000,
    matingSeason: 300,
    selectRate: 0.01,
    mutateRate: 0.1
  })
  self.evolve.on('result', function (data) {
    self.neuralNetwork.importAsJSON(data)
  })
  self.neuroPanel.ifaceInputGame.value = 'tetris'
  self.neuroPanel.ifaceInputGame.click()
  // var testnet = require('../data/circle.json')
  // testnet.links.forEach(element => {
  //   var iv = Math.abs(element.value)
  //   if (iv > 3) element.value = 3 * (element.value > 0 ? +1 : -1)
  // })
  // console.log('???' + JSON.stringify(testnet.links))
  // // console.log('???' + testnet)
  // self.neuralNetwork.importAsJSON(testnet)
}

window.onload = function () {
  var editor = new NeuroEditor()
  document.body.appendChild(editor.container)
  editor.open()
}

},{"../data/tetris180502.json":1,"./evolve":12,"./neuralnetwork":25,"./neurocanvas":26,"./neurocontrol":27}],25:[function(require,module,exports){
var EventEmitter = require('events').EventEmitter
var inherits = require('inherits')
inherits(NeuralNetwork, EventEmitter)

var ACTIVATE_METHOD = {
  sigmoid: 'sigmoid',
  relu: 'relu',
  thresold: 'thresold',
  identity: 'identity'
}
var TO = '->'
// -------------------------------------------------
// Neural Network
// -------------------------------------------------
function NeuralNetwork (options) {
  var self = this
  if (!(self instanceof NeuralNetwork)) return new NeuralNetwork(options)
  self.learningRate = options.learningRate || 0.01
  self.contentID = options.contentID
  self.neuronData = { nodes: [], links: [] } // for storing yjs data array
  self.neuron = {} // for binding yjs data array to object -> better finding performence
  self.route = {}
  // if (!options.data) { // sample data
  //   self.addNode({ id: '1', group: 'input', x: 100, y: 100, sumofw: 0, bias: 0, actMethod: ACTIVATE_METHOD.identity, actvalue: 0 })
  //   self.addNode({ id: '2', group: 'input', x: 150, y: 150, sumofw: 0, bias: 0, actMethod: ACTIVATE_METHOD.identity, actvalue: 0 })
  //   self.addLink({ source: '1', target: '2', value: 1, delta: 0 })
  // }
  self.outputs = []
  self.selfTrains = []
}

NeuralNetwork.prototype.getNode = function (nodeid) {
  var self = this
  return self.neuron[nodeid]
}
NeuralNetwork.prototype.getLink = function (source, target) {
  var self = this
  return self.route[source + TO + target]
}

NeuralNetwork.prototype.setNodes = function (data) {
  var self = this
  self.neuronData.nodes = data
  self.neuronData.nodes.forEach(function (node) {
    self.neuron[node.id] = node
  })
}
NeuralNetwork.prototype.setLinks = function (data) {
  var self = this
  self.neuronData.links = data
  self.neuronData.links.forEach(function (link) {
    self.route[link.source + TO + link.target] = link
  })
}

NeuralNetwork.prototype.addNode = function (data, needSync) {
  var self = this
  // var isExist = self.neuronData.nodes.find(function (node) { return data.id === node.id })
  var isExist = self.getNode(data.id)
  if (isExist) return false

  if (!data.id) data.id = Math.random().toString(36).substr(2)
  if (!data.group) data.group = '0'
  if (!data.x) data.x = 0
  if (!data.y) data.y = 0
  if (!data.bias) data.bias = 0
  if (!data.actMethod) data.actMethod = ACTIVATE_METHOD.identity
  // actvalue와 sumofw는 sync하지 않는다.
  data.sumofw = 0
  data.actvalue = 0
  self.neuronData.nodes.push(data)
  self.neuron[data.id] = data

  if (needSync) {
    self.emit('changeNode', {
      type: 'insert',
      contentID: self.contentID,
      value: data
    })
  }
  return self.neuron[data.id]
}

NeuralNetwork.prototype.updateNode = function (data, needSync) {
  var self = this
  var node = self.getNode(data.id)
  if (!node) return
  if (data.group) node.group = data.group
  if (data.bias) node.bias = data.bias
  if (data.actMethod) node.actMethod = data.actMethod
  if (data.x) node.x = data.x
  if (data.y) node.y = data.y

  if (needSync) {
    self.emit('changeNode', {
      type: 'update',
      contentID: self.contentID,
      value: data
    })
  }
}
NeuralNetwork.prototype.deleteNode = function (data, needSync) {
  var self = this
  var isExist = self.getNode(data.id)
  if (!isExist) return
  self.neuronData.nodes.splice(self.neuronData.nodes.indexOf(isExist), 1)
  delete self.neuron[data.id]
  if (needSync) {
    self.emit('changeNode', {
      type: 'delete',
      contentID: self.contentID,
      value: data
    })
    console.log('remove test 4')
  }
}

NeuralNetwork.prototype.addLink = function (data, needSync) {
  var self = this
  // var isExist = self.neuronData.links.find(function (link) { return data.source === link.source && data.target === link.target })
  var isExist = self.getLink(data.source, data.target)
  if (isExist) return false
  if (!self.getNode(data.source) || !self.getNode(data.target)) return false

  if (!data.value) data.value = 0
  if (!data.delta) data.delta = 0
  self.neuronData.links.push(data)
  self.route[data.source + TO + data.target] = data
  if (needSync) {
    self.emit('changeLink', {
      type: 'insert',
      contentID: self.contentID,
      value: data
    })
  }
  return true
}
NeuralNetwork.prototype.updateLink = function (data, needSync) {
  var self = this
  var link = self.getLink(data.source, data.target)
  if (!link) return
  if (data.value) link.value = data.value
  if (data.delta) link.delta = data.delta
  // console.log('track update link: ' + JSON.stringify(data))
  if (needSync) {
    self.emit('changeLink', {
      type: 'update',
      contentID: self.contentID,
      value: data
    })
  }
}
NeuralNetwork.prototype.deleteLink = function (data, needSync) {
  var self = this
  var isExist = self.getLink(data.source, data.target)
  if (!isExist) return
  // self.neuronData.links.splice(self.neuronData.links.indexOf(isExist), 1)
  self.neuronData.links.splice(self.neuronData.links.indexOf(isExist), 1)
  delete self.route[data.source + TO + data.target]
  if (needSync) {
    self.emit('changeLink', {
      type: 'delete',
      contentID: self.contentID,
      value: data
    })
  }
}

NeuralNetwork.prototype.process = function (inputData) {
  var self = this
  if (!Array.isArray(inputData)) return console.warn('NeuralNetwork: cannot process non-array data!')
  self.outputs = []
  self.selfTrains = []
  var inputIndex = 0
  for (var i = 0; i < self.neuronData.nodes.length; i++) {
    if (self.neuronData.nodes[i].group === 'input') {
      self.neuronData.nodes[i].actvalue = inputData[inputIndex]
      inputIndex++
    } else {
      if (self.neuronData.nodes[i].group === 'output') {
        self.outputs.push(self.neuronData.nodes[i])
      } else if (self.neuronData.nodes[i].group === 'selftrain') {
        self.selfTrains.push(self.neuronData.nodes[i])
      }
      self.neuronData.nodes[i].actvalue = self.activate(self.neuronData.nodes[i].sumofw, self.neuronData.nodes[i].actMethod)
    }
    self.neuronData.nodes[i].sumofw = 0
  }
  for (var j = 0; j < self.neuronData.links.length; j++) {
    self.neuron[self.neuronData.links[j].target].sumofw += self.neuron[self.neuronData.links[j].source].actvalue * self.neuronData.links[j].value
  }
  // 기존의 방식이 반복문을 이중으로 돌려서 자원 소모가 많아서 처리방식을 단순하게 고쳐보았다.
  // 장점: 처리가 더 빠르다.
  // 단점: 기존의 퍼셉트론 방식은 인풋과 같은 턴에 아웃풋이 나왔는데 이 방식으로 하면 거치는 레이어 수만큼 아웃풋 턴이 밀린다.
  // 그러나 이 방식이 인간의 뉴런 동작방식과 더 유사한 점도 있다.

  // var inputIndex = 0
  // for (var i = 0; i < self.neuronData.nodes.length; i++) {
  //   if (self.neuronData.nodes[i].group === 'input') {
  //     // console.log('hey ' + self.neuronData.nodes[i].id + ' ' + inputData[inputIndex])
  //     self.neuronData.nodes[i].actvalue = inputData[inputIndex]
  //     inputIndex++
  //   } else {
  //     var sumofw = 0
  //     for (var j = 0; j < self.neuronData.links.length; j++) {
  //       if (self.neuronData.links[j].target === self.neuronData.nodes[i].id) {
  //         var source = self.neuronData.nodes.find(function (cv) { return cv.id === self.neuronData.links[j].source })
  //         sumofw += source.actvalue * self.neuronData.links[j].value
  //       }
  //     }
  //     self.neuronData.nodes[i].sumofw = sumofw + Number(self.neuronData.nodes[i].bias)
  //     self.neuronData.nodes[i].actvalue = self.activate(self.neuronData.nodes[i].sumofw, self.neuronData.nodes[i].actMethod)
  //   }
  // }
}

NeuralNetwork.prototype.getOutput = function () {
  var self = this
  // for (var i = 0; i < self.neuronData.nodes.length; i++) {
  //   if (self.neuronData.nodes[i].group === 'output') {
  //     outputArray.push(self.neuronData.nodes[i].actvalue)
  //   }
  // }
  return self.outputs.map(function (value) {
    return value.actvalue
  })
}

NeuralNetwork.prototype.getSelfTrain = function () {
  var self = this
  return self.selfTrains.map(function (value) {
    return value.actvalue
  })
}

NeuralNetwork.prototype.activate = function (val, methodName) {
  methodName = !methodName ? ACTIVATE_METHOD.identity : methodName
  switch (methodName) {
    case ACTIVATE_METHOD.sigmoid:
      return 1 / (1 + Math.exp(-val))
    case ACTIVATE_METHOD.relu:
      return Math.max(0, val)
    case ACTIVATE_METHOD.thresold:
      if (val > 0) return 1.0
      else return 0.0
    case ACTIVATE_METHOD.identity:
    default:
      return val
  }
}
NeuralNetwork.prototype.act_grad = function (val, methodName) {
  methodName = !methodName ? ACTIVATE_METHOD.identity : methodName
  switch (methodName) {
    case ACTIVATE_METHOD.sigmoid:
      return (1.0 - val) * val
    case ACTIVATE_METHOD.relu:
      return (val > 0) ? 1.0 : 0.0
    case ACTIVATE_METHOD.thresold:
      return (val > 0) ? 1.0 : 0.0
    case ACTIVATE_METHOD.identity:
    default:
      return 1.0
  }
}

NeuralNetwork.prototype.importAsJSON = function (importData) {
  var self = this
  if (!importData.nodes || !importData.links) return

  importData.nodes.forEach(function (node) {
    var isExist = self.getNode(node.id)
    if (isExist) self.updateNode(node, true)
    else self.addNode(node, true)
  })
  importData.links.forEach(function (link) {
    var isExist = self.getLink(link.source, link.target)
    if (isExist) self.updateLink(link, true)
    else self.addLink(link, true)
  })
}

NeuralNetwork.prototype.saveAsJSON = function () {
  var self = this
  var outputNeurons = []
  var outputRoutes = []

  self.neuronData.nodes.forEach(function (node) {
    outputNeurons.push({
      id: node.id,
      group: node.group,
      x: node.x,
      y: node.y,
      bias: node.bias,
      sumofw: node.sumofw,
      actMethod: node.actMethod,
      actvalue: node.actvalue
    })
  })
  self.neuronData.links.forEach(function (link) {
    outputRoutes.push({
      source: link.source,
      target: link.target,
      value: link.value
    })
  })

  return {
    nodes: outputNeurons,
    links: outputRoutes
  }
}

NeuralNetwork.prototype.applyRandomWeight = function (learningRate, targetGroup, direction, mutation) {
  var self = this
  learningRate = learningRate || self.learningRate
  targetGroup = targetGroup || 'all'
  direction = direction || 'both'
  // console.log('random weight ', learningRate, ' ', targetGroup, ' ', direction)
  if (targetGroup === 'all') {
    for (var k = 0; k < self.neuronData.links.length; k++) {
      if (mutation && (Math.floor(Math.random() * 100 * mutation))) break
      self.updateLink({
        source: self.neuronData.links[k].source,
        target: self.neuronData.links[k].target,
        value: Number(self.neuronData.links[k].value) + self.neuronData.links[k].delta,
        delta: (Math.random() * 4 - 2) * Number(learningRate)
      }, true)
      // self.neuronData.links[k].delta = (Math.random() * 4 - 2) * Number(learningRate)
      // self.neuronData.links[k].value = Number(self.neuronData.links[k].value) + self.neuronData.links[k].delta
    }
    return
  }

  for (var i = 0; i < self.neuronData.nodes.length; i++) {
    if (self.neuronData.nodes[i].group === targetGroup || self.neuronData.nodes[i].group === Number(targetGroup)) {
      for (var j = 0; j < self.neuronData.links.length; j++) {
        if ((direction === 'from' || direction === 'both') && self.neuronData.links[j].target === self.neuronData.nodes[i].id) {
          // direction이 from 인데 link.target을 쓰는 이유: 사용자는 뉴런을 선택한 관점에서 from에 해당하는 통로 가중치를 조정하길 원한다.
          // links.target은 통로의 관점에서 보기 때문에 통로가 바라보는 뉴런이 일치하는지 확인해야 한다.
          self.updateLink({
            source: self.neuronData.links[j].source,
            target: self.neuronData.links[j].target,
            value: Number(self.neuronData.links[j].value) + self.neuronData.links[j].delta,
            delta: (Math.random() * 4 - 2) * Number(learningRate)
          }, true)
        } else if ((direction === 'to' || direction === 'both') && self.neuronData.links[j].source === self.neuronData.nodes[i].id) {
          self.updateLink({
            source: self.neuronData.links[j].source,
            target: self.neuronData.links[j].target,
            value: Number(self.neuronData.links[j].value) + self.neuronData.links[j].delta,
            delta: (Math.random() * 4 - 2) * Number(learningRate)
          }, true)
        }
      }
    }
  }
}

NeuralNetwork.prototype.applyAccelerateWeight = function (learningRate, targetGroup, direction) {
  var self = this
  // console.log('Accelerate weight ', learningRate, ' ', targetGroup, ' ', direction)
  if (targetGroup === 'all') {
    for (var k = 0; k < self.neuronData.links.length; k++) {
      self.updateLink({
        source: self.neuronData.links[k].source,
        target: self.neuronData.links[k].target,
        value: Number(self.neuronData.links[k].value) + self.neuronData.links[k].delta,
        delta: self.neuronData.links[k].delta * Number(learningRate)
      }, true)
    }
    return
  }

  for (var i = 0; i < self.neuronData.nodes.length; i++) {
    if (self.neuronData.nodes[i].group === targetGroup || self.neuronData.nodes[i].group === Number(targetGroup)) {
      for (var j = 0; j < self.neuronData.links.length; j++) {
        if ((direction === 'from' || direction === 'both') && self.neuronData.links[j].target === self.neuronData.nodes[i].id) {
          // direction이 from 인데 link.target을 쓰는 이유: 사용자는 뉴런을 선택한 관점에서 from에 해당하는 통로 가중치를 조정하길 원한다.
          // links.target은 통로의 관점에서 보기 때문에 통로가 바라보는 뉴런이 일치하는지 확인해야 한다.
          self.updateLink({
            source: self.neuronData.links[j].source,
            target: self.neuronData.links[j].target,
            value: Number(self.neuronData.links[j].value) + self.neuronData.links[j].delta,
            delta: self.neuronData.links[j].delta * Number(learningRate)
          }, true)
        } else if ((direction === 'to' || direction === 'both') && self.neuronData.links[j].source === self.neuronData.nodes[i].id) {
          self.updateLink({
            source: self.neuronData.links[j].source,
            target: self.neuronData.links[j].target,
            value: Number(self.neuronData.links[j].value) + self.neuronData.links[j].delta,
            delta: self.neuronData.links[j].delta * Number(learningRate)
          }, true)
        }
      }
    }
  }
}

NeuralNetwork.prototype.selfTraining = function (learningRate) {
  var self = this
  var traindata = self.getSelfTrain()
  // console.log('self train attempt: ' + traindata[0])
  if (!traindata.length) return
  if (traindata[0]) {
    self.applyAccelerateWeight(learningRate, 'all')
  } else {
    self.applyRandomWeight(learningRate, 'all')
  }
}

NeuralNetwork.prototype.createNeuronCorps = function (offsetX, offsetY, sizeX, sizeY, options) {
  var self = this

  for (var i = 0; i < sizeY; i++) {
    for (var j = 0; j < sizeX; j++) {
      var obj = JSON.parse(JSON.stringify(options))
      obj.x = offsetX + j * 35
      obj.y = offsetY + i * 35
      self.addNode(obj, true)
    }
  }
}

NeuralNetwork.prototype.createConnectionsFull = function (sourceGroup, targetGroup, fixedValue) {
  var self = this

  for (var i = 0; i < self.neuronData.nodes.length; i++) {
    if (new String(self.neuronData.nodes[i].group).valueOf() == new String(sourceGroup).valueOf()) {
      for (var j = 0; j < self.neuronData.nodes.length; j++) {
        if (new String(self.neuronData.nodes[j].group).valueOf() == new String(targetGroup).valueOf()) {
          self.addLink({
            source: self.neuronData.nodes[i].id,
            target: self.neuronData.nodes[j].id,
            value: fixedValue || (Math.random() * 6 - 3)
          }, true)
        }
      }
    }
  }
}

NeuralNetwork.prototype.createConnectionsCNN = function (sourceGroup, targetGroup, sizeX, sizeY, kernel) {
  var self = this
  var usePadding = true
  var currentX = 0
  var currentY = 0
  var tempSourceNodes = []
  var tempTargetNodes = []

  if (!kernel) {
    kernel = {
      lt: 1,
      t: 0,
      rt: 1,
      l: 0,
      c: 1,
      r: 0,
      lb: 1,
      b: 0,
      rb: 1
    }
  }
  var topPads = []
  var bottomPads = []
  var leftPads = []
  var rightPads = []
  var vertaxPads = [] // (left top), (right top), (left bottom), (right bottom)

  tempSourceNodes.push([])
  for (var i = 0; i < self.neuronData.nodes.length; i++) {
    if (new String(self.neuronData.nodes[i].group).valueOf() == new String(sourceGroup).valueOf()) {
      tempSourceNodes[currentY].push(self.neuronData.nodes[i])
      currentX++
      if (currentX === sizeX) {
        currentX = 0
        tempSourceNodes.push([])
        currentY++
      }
    }
  }
  currentX = 0
  currentY = 0
  tempTargetNodes.push([])
  for (var j = 0; j < self.neuronData.nodes.length; j++) {
    if (new String(self.neuronData.nodes[j].group).valueOf() == new String(targetGroup).valueOf()) {
      tempTargetNodes[currentY].push(self.neuronData.nodes[j])
      currentX++
      if (currentX === sizeX) {
        currentX = 0
        tempTargetNodes.push([])
        currentY++
      }
    }
  }

  if (tempSourceNodes.length !== tempTargetNodes.length) {
    console.log('Error: different shape between groups.')
    return
  }

  if (usePadding) {
    for (i = 0; i < sizeY; i++) {
      leftPads.push(self.addNode({ x: tempSourceNodes[i][0].x - 30, y: tempSourceNodes[i][0].y, group: 10 }, true))
      rightPads.push(self.addNode({ x: tempSourceNodes[i][sizeX - 1].x + 30, y: tempSourceNodes[i][sizeX - 1].y, group: 10 }, true))
    }
    for (j = 0; j < sizeX; j++) {
      topPads.push(self.addNode({ x: tempSourceNodes[0][j].x, y: tempSourceNodes[0][j].y - 30, group: 10 }, true))
      bottomPads.push(self.addNode({ x: tempSourceNodes[sizeY - 1][j].x, y: tempSourceNodes[sizeY - 1][j].y + 30, group: 10 }, true))
    }

    vertaxPads.push(self.addNode({ x: tempSourceNodes[0][0].x - 30, y: tempSourceNodes[0][0].y - 30, group: 10 }, true))
    vertaxPads.push(self.addNode({ x: tempSourceNodes[0][sizeX - 1].x + 30, y: tempSourceNodes[0][sizeX - 1].y - 30, group: 10 }, true))
    vertaxPads.push(self.addNode({ x: tempSourceNodes[sizeY - 1][0].x - 30, y: tempSourceNodes[sizeY - 1][0].y + 30, group: 10 }, true))
    vertaxPads.push(self.addNode({ x: tempSourceNodes[sizeY - 1][sizeX - 1].x + 30, y: tempSourceNodes[sizeY - 1][sizeX - 1].y + 30, group: 10 }, true))
  }

  for (var l = 0; l < tempTargetNodes.length; l++) {
    for (var k = 0; k < tempTargetNodes[l].length; k++) {
      self.addLink({ source: tempSourceNodes[l][k].id, target: tempTargetNodes[l][k].id, value: kernel.c }, true)

      if ((l - 1) < 0 && (k - 1) < 0 && usePadding) { // left top padding
        self.addLink({ source: vertaxPads[0].id, target: tempTargetNodes[l][k].id, value: kernel.lt }, true)
        self.addLink({ source: leftPads[l].id, target: tempTargetNodes[l][k].id, value: kernel.l }, true)
        self.addLink({ source: leftPads[l + 1].id, target: tempTargetNodes[l][k].id, value: kernel.lb }, true)
        self.addLink({ source: topPads[k].id, target: tempTargetNodes[l][k].id, value: kernel.t }, true)
        self.addLink({ source: tempSourceNodes[l + 1][k].id, target: tempTargetNodes[l][k].id, value: kernel.b }, true)
        self.addLink({ source: topPads[k + 1].id, target: tempTargetNodes[l][k].id, value: kernel.rt }, true)
        self.addLink({ source: tempSourceNodes[l][k + 1].id, target: tempTargetNodes[l][k].id, value: kernel.r }, true)
        self.addLink({ source: tempSourceNodes[l + 1][k + 1].id, target: tempTargetNodes[l][k].id, value: kernel.rb }, true)
      } else if ((l + 1) >= sizeY && (k - 1) < 0 && usePadding) { // left bottom padding
        self.addLink({ source: leftPads[l - 1].id, target: tempTargetNodes[l][k].id, value: kernel.lt }, true)
        self.addLink({ source: leftPads[l].id, target: tempTargetNodes[l][k].id, value: kernel.l }, true)
        self.addLink({ source: vertaxPads[2].id, target: tempTargetNodes[l][k].id, value: kernel.lb }, true)
        self.addLink({ source: tempSourceNodes[l - 1][k].id, target: tempTargetNodes[l][k].id, value: kernel.t }, true)
        self.addLink({ source: bottomPads[k].id, target: tempTargetNodes[l][k].id, value: kernel.b }, true)
        self.addLink({ source: tempSourceNodes[l - 1][k + 1].id, target: tempTargetNodes[l][k].id, value: kernel.rt }, true)
        self.addLink({ source: tempSourceNodes[l][k + 1].id, target: tempTargetNodes[l][k].id, value: kernel.r }, true)
        self.addLink({ source: bottomPads[k + 1].id, target: tempTargetNodes[l][k].id, value: kernel.rb }, true)
      } else if ((l - 1) < 0 && (k + 1) >= sizeX && usePadding) { // right top padding
        self.addLink({ source: topPads[k - 1].id, target: tempTargetNodes[l][k].id, value: kernel.lt }, true)
        self.addLink({ source: tempSourceNodes[l][k - 1].id, target: tempTargetNodes[l][k].id, value: kernel.l }, true)
        self.addLink({ source: tempSourceNodes[l + 1][k - 1].id, target: tempTargetNodes[l][k].id, value: kernel.lb }, true)
        self.addLink({ source: topPads[k].id, target: tempTargetNodes[l][k].id, value: kernel.t }, true)
        self.addLink({ source: tempSourceNodes[l + 1][k].id, target: tempTargetNodes[l][k].id, value: kernel.b }, true)
        self.addLink({ source: vertaxPads[1].id, target: tempTargetNodes[l][k].id, value: kernel.rt }, true)
        self.addLink({ source: rightPads[l].id, target: tempTargetNodes[l][k].id, value: kernel.r }, true)
        self.addLink({ source: rightPads[l + 1].id, target: tempTargetNodes[l][k].id, value: kernel.rb }, true)
      } else if ((l + 1) >= sizeY && (k + 1) >= sizeX && usePadding) { // right bottom padding
        self.addLink({ source: tempSourceNodes[l - 1][k - 1].id, target: tempTargetNodes[l][k].id, value: kernel.lt }, true)
        self.addLink({ source: tempSourceNodes[l][k - 1].id, target: tempTargetNodes[l][k].id, value: kernel.l }, true)
        self.addLink({ source: bottomPads[k - 1].id, target: tempTargetNodes[l][k].id, value: kernel.lb }, true)
        self.addLink({ source: tempSourceNodes[l - 1][k].id, target: tempTargetNodes[l][k].id, value: kernel.t }, true)
        self.addLink({ source: bottomPads[k].id, target: tempTargetNodes[l][k].id, value: kernel.b }, true)
        self.addLink({ source: rightPads[l - 1].id, target: tempTargetNodes[l][k].id, value: kernel.rt }, true)
        self.addLink({ source: rightPads[l].id, target: tempTargetNodes[l][k].id, value: kernel.r }, true)
        self.addLink({ source: vertaxPads[3].id, target: tempTargetNodes[l][k].id, value: kernel.rb }, true)
      } else if ((k - 1) < 0 && usePadding) { // left padding
        self.addLink({ source: leftPads[l - 1].id, target: tempTargetNodes[l][k].id, value: kernel.lt }, true)
        self.addLink({ source: leftPads[l].id, target: tempTargetNodes[l][k].id, value: kernel.l }, true)
        self.addLink({ source: leftPads[l + 1].id, target: tempTargetNodes[l][k].id, value: kernel.lb }, true)
        self.addLink({ source: tempSourceNodes[l - 1][k].id, target: tempTargetNodes[l][k].id, value: kernel.t }, true)
        self.addLink({ source: tempSourceNodes[l + 1][k].id, target: tempTargetNodes[l][k].id, value: kernel.b }, true)
        self.addLink({ source: tempSourceNodes[l - 1][k + 1].id, target: tempTargetNodes[l][k].id, value: kernel.rt }, true)
        self.addLink({ source: tempSourceNodes[l][k + 1].id, target: tempTargetNodes[l][k].id, value: kernel.r }, true)
        self.addLink({ source: tempSourceNodes[l + 1][k + 1].id, target: tempTargetNodes[l][k].id, value: kernel.rb }, true)
      } else if ((k + 1) >= sizeX && usePadding) { // right padding
        self.addLink({ source: tempSourceNodes[l - 1][k - 1].id, target: tempTargetNodes[l][k].id, value: kernel.lt }, true)
        self.addLink({ source: tempSourceNodes[l][k - 1].id, target: tempTargetNodes[l][k].id, value: kernel.l }, true)
        self.addLink({ source: tempSourceNodes[l + 1][k - 1].id, target: tempTargetNodes[l][k].id, value: kernel.lb }, true)
        self.addLink({ source: tempSourceNodes[l - 1][k].id, target: tempTargetNodes[l][k].id, value: kernel.t }, true)
        self.addLink({ source: tempSourceNodes[l + 1][k].id, target: tempTargetNodes[l][k].id, value: kernel.b }, true)
        self.addLink({ source: rightPads[l - 1].id, target: tempTargetNodes[l][k].id, value: kernel.rt }, true)
        self.addLink({ source: rightPads[l].id, target: tempTargetNodes[l][k].id, value: kernel.r }, true)
        self.addLink({ source: rightPads[l + 1].id, target: tempTargetNodes[l][k].id, value: kernel.rb }, true)
      } else if ((l - 1) < 0 && usePadding) { // top padding
        self.addLink({ source: topPads[k - 1].id, target: tempTargetNodes[l][k].id, value: kernel.lt }, true)
        self.addLink({ source: tempSourceNodes[l][k - 1].id, target: tempTargetNodes[l][k].id, value: kernel.l }, true)
        self.addLink({ source: tempSourceNodes[l + 1][k - 1].id, target: tempTargetNodes[l][k].id, value: kernel.lb }, true)
        self.addLink({ source: topPads[k].id, target: tempTargetNodes[l][k].id, value: kernel.t }, true)
        self.addLink({ source: tempSourceNodes[l + 1][k].id, target: tempTargetNodes[l][k].id, value: kernel.b }, true)
        self.addLink({ source: topPads[k + 1].id, target: tempTargetNodes[l][k].id, value: kernel.rt }, true)
        self.addLink({ source: tempSourceNodes[l][k + 1].id, target: tempTargetNodes[l][k].id, value: kernel.r }, true)
        self.addLink({ source: tempSourceNodes[l + 1][k + 1].id, target: tempTargetNodes[l][k].id, value: kernel.rb }, true)
      } else if ((l + 1) >= sizeY && usePadding) { // bottom padding
        self.addLink({ source: tempSourceNodes[l - 1][k - 1].id, target: tempTargetNodes[l][k].id, value: kernel.lt }, true)
        self.addLink({ source: tempSourceNodes[l][k - 1].id, target: tempTargetNodes[l][k].id, value: kernel.l }, true)
        self.addLink({ source: bottomPads[k - 1].id, target: tempTargetNodes[l][k].id, value: kernel.lb }, true)
        self.addLink({ source: tempSourceNodes[l - 1][k].id, target: tempTargetNodes[l][k].id, value: kernel.t }, true)
        self.addLink({ source: bottomPads[k].id, target: tempTargetNodes[l][k].id, value: kernel.b }, true)
        self.addLink({ source: tempSourceNodes[l - 1][k + 1].id, target: tempTargetNodes[l][k].id, value: kernel.rt }, true)
        self.addLink({ source: tempSourceNodes[l][k + 1].id, target: tempTargetNodes[l][k].id, value: kernel.r }, true)
        self.addLink({ source: bottomPads[k + 1].id, target: tempTargetNodes[l][k].id, value: kernel.rb }, true)
      } else { // center
        self.addLink({ source: tempSourceNodes[l - 1][k - 1].id, target: tempTargetNodes[l][k].id, value: kernel.lt }, true)
        self.addLink({ source: tempSourceNodes[l][k - 1].id, target: tempTargetNodes[l][k].id, value: kernel.l }, true)
        self.addLink({ source: tempSourceNodes[l + 1][k - 1].id, target: tempTargetNodes[l][k].id, value: kernel.lb }, true)
        self.addLink({ source: tempSourceNodes[l - 1][k].id, target: tempTargetNodes[l][k].id, value: kernel.t }, true)
        self.addLink({ source: tempSourceNodes[l + 1][k].id, target: tempTargetNodes[l][k].id, value: kernel.b }, true)
        self.addLink({ source: tempSourceNodes[l - 1][k + 1].id, target: tempTargetNodes[l][k].id, value: kernel.rt }, true)
        self.addLink({ source: tempSourceNodes[l][k + 1].id, target: tempTargetNodes[l][k].id, value: kernel.r }, true)
        self.addLink({ source: tempSourceNodes[l + 1][k + 1].id, target: tempTargetNodes[l][k].id, value: kernel.rb }, true)
      }
    }
  }
}

NeuralNetwork.prototype.crossover = function (importData) { // json gene data
  var self = this
  if (!importData.nodes || !importData.links) return null
  var outputGene = {
    nodes: [],
    links: []
  }

  importData.nodes.forEach(function (node) {
    var mNode = self.getNode(node.id)
    if (mNode) {
      if (Math.floor(Math.random() * 2)) {
        outputGene.nodes.push({
          id: mNode.id,
          group: mNode.group,
          x: mNode.x,
          y: mNode.y,
          bias: mNode.bias,
          sumofw: mNode.sumofw,
          actMethod: mNode.actMethod,
          actvalue: mNode.actvalue
        })
      } else {
        outputGene.nodes.push({
          id: node.id,
          group: node.group,
          x: node.x,
          y: node.y,
          bias: node.bias,
          sumofw: node.sumofw,
          actMethod: node.actMethod,
          actvalue: node.actvalue
        })
      }
    }
  })
  importData.links.forEach(function (link) {
    var mLink = self.getLink(link.source, link.target)
    if (mLink) {
      if (Math.floor(Math.random() * 2)) {
        outputGene.links.push({
          source: mLink.source,
          target: mLink.target,
          value: mLink.value
        })
      } else {
        outputGene.links.push({
          source: link.source,
          target: link.target,
          value: link.value
        })
      }
    }
  })

  return outputGene
}

NeuralNetwork.prototype.mutate = function (mutateRate) {
  var self = this
  for (var k = 0; k < self.neuronData.links.length; k++) {
    self.updateLink({
      source: self.neuronData.links[k].source,
      target: self.neuronData.links[k].target,
      value: Number(self.neuronData.links[k].value) + (Math.random() * 4 - 2) * Number(mutateRate),
      delta: 0
    }, true)
  }
}

module.exports = NeuralNetwork

},{"events":30,"inherits":2}],26:[function(require,module,exports){
/* global PIXI */

var util = require('./util')
var EventEmitter = require('events').EventEmitter
var inherits = require('inherits')
var hslToHexColor = require('./hsl')

var CANVAS_STATE = {
  view: 'view',
  edit: 'edit',
  pause: 'pause'
}
var TO = '->'

inherits(NeuroCanvas, EventEmitter)
function NeuroCanvas (options) {
  var self = this
  self.stage = new PIXI.Container()
  self.renderer = PIXI.autoDetectRenderer(options.width || 800, options.height || 600,
      {antialias: !0, transparent: !0, resolution: 1})
  self.container = options.container || document.body
  self.neuralNetwork = options.neuralNetwork
  self.neuroPanel = options.neuroPanel
  console.log('NeuroCanvas created.')

  self.container.appendChild(self.renderer.view)
  if (options.data) {
    self.initCanvas(options.data)
  }
  window.addEventListener('resize', this.canvasResize.bind(this), false)
}
NeuroCanvas.prototype.canvasResize = function (event) {
  this.renderer.resize(this.container.clientWidth, this.container.clientHeight)
}
/**
 * Initialaze canvas
 */
NeuroCanvas.prototype.initCanvas = function () {
  var self = this
  self.canvasState = CANVAS_STATE.view
  self.holdedKey = -1 // hold only one key.
  self.selectedLink = null
  self.selectedNode = null
  self.draggingSprite = false
  self.draggingStage = false
  self.draggingStageDelta = 0
  self.pointerupTracker = false

  // var for Zoom and Pan
  self.main_layer_zoom_scale = 1
  self.main_layer_zoom_scalemax = 20
  self.main_layer_zoom_scalemin = 0.4
  self.main_layer_zoom_offset_x = 0
  self.main_layer_zoom_offset_y = 0

  self.linkClip = new PIXI.Graphics()
  self.stage.addChild(self.linkClip)
  self.neuralNetwork.neuronData.links.forEach(function (link, i) {
    link.sprite = self.createRoute(link.source, link.target, self.linkClip, link)
  })

  self.nodeClip = new PIXI.Graphics()
  self.stage.addChild(self.nodeClip)
  self.neuralNetwork.neuronData.nodes.forEach(function (node, i) {
    node.sprite = self.createNeuron(node.x, node.y, self.nodeClip, node)
  })

  self.tempArrow = new PIXI.Graphics()
  self.tempArrow.interactive = false
  self.tempArrow.buttonMode = false
  self.stage.addChild(self.tempArrow)
  self.draggingArrow = false

  // set main loop method
  util.loopProcess.addProcess(self.renderLoop.bind(self))

  document.body.addEventListener('keydown', self.keydown.bind(self))
  document.body.addEventListener('keyup', self.keydown.bind(self))

  // Attach cross browser mouse wheel listeners
  if (document.body.addEventListener) {
    self.container.addEventListener('mousewheel', self.onZoom.bind(self), false) // Chrome/Safari/Opera
    self.container.addEventListener('DOMMouseScroll', self.onZoom.bind(self), false) // Firefox
  } else if (document.body.attachEvent) {
    self.container.attachEvent('onmousewheel', self.onZoom.bind(self)) // IE
  }

  self.renderer.plugins.interaction
      .on('pointerdown', function (event) {
        if (!self.draggingSprite && !self.draggingArrow) {
          self.draggingStage = true
          self.draggingStageDelta = 0
          self.clientX = -1
          self.clientY = -1
        }
      })
      .on('pointerup', function (event) {
        if (self.draggingStage && self.draggingStageDelta < 5 && self.canvasState === CANVAS_STATE.edit) {
          // on click
          var pos = event.data.getLocalPosition(self.stage)
          var nodeData = {
            id: Math.random().toString(36).substr(2),
            x: pos.x,
            y: pos.y
          }
          self.neuralNetwork.addNode(nodeData, true)
          self.selectedNode = self.neuralNetwork.getNode(nodeData.id)
          self.selectedNode.sprite = self.createNeuron(self.selectedNode.x, self.selectedNode.y, self.nodeClip, self.selectedNode)
          self.emit('neuronSelected', self.selectedNode.id)
        }
        self.draggingStage = false
        self.tempArrow.clear()
        self.draggingArrow = false
        self.tempArrow.data = null

        if (self.pointerupTracker) { // ignore, if sprite event occur
          self.pointerupTracker = false
        } else {
          self.selectedNode = null
          self.selectedLink = null
        }
      })
      .on('pointermove', function (event) {
        // if (!self.draggingSprite || !self.selectedNode || !self.selectedLink)
        if (self.draggingStage && !self.draggingSprite && !self.draggingArrow) {
          self.draggingStageDelta += 1
          // If this is the first iteration through then set clientX and clientY to match the inital mouse position
          if (self.draggingStageDelta < 5) return
          var pos = event.data.global
          if (self.clientX === -1 && self.clientY === -1) {
            self.clientX = pos.x
            self.clientY = pos.y
          }

          var xPos
          var yPos
          // Run a relative check of the last two mouse positions to detect which direction to pan on x
          if (pos.x === self.clientX) {
            xPos = 0
          } else if (pos.x < self.clientX) {
            xPos = -Math.abs(pos.x - self.clientX)
          } else if (pos.x > self.clientX) {
            xPos = Math.abs(pos.x - self.clientX)
          }

          // Run a relative check of the last two mouse positions to detect which direction to pan on y
          if (pos.y === self.clientY) {
            yPos = 0
          } else if (pos.y < self.clientY) {
            yPos = -Math.abs(pos.y - self.clientY)
          } else if (pos.y > self.clientY) {
            yPos = Math.abs(self.clientY - pos.y)
          }

          // Set the relative positions for comparison in the next frame
          self.clientX = pos.x
          self.clientY = pos.y

          // Change the main layer zoom offset x and y for use when mouse wheel listeners are fired.
          self.main_layer_zoom_offset_x = self.stage.position.x + xPos
          self.main_layer_zoom_offset_y = self.stage.position.y + yPos

          // Move the main layer based on above calucalations
          self.stage.position.set(self.main_layer_zoom_offset_x, self.main_layer_zoom_offset_y)
        }
      })
}

NeuroCanvas.prototype.onZoom = function (event) {
  var self = this
  // Find the direction that was scrolled
  var direction = wheelDirection(event)

  // Set the old scale to be referenced later
  var oldScale = self.main_layer_zoom_scale

  // Find the position of the clients mouse
  var pos = { x: event.clientX, y: event.clientY }

  // Manipulate the scale based on direction
  self.main_layer_zoom_scale = oldScale + direction * 0.4

  // Check to see that the scale is not outside of the specified bounds
  if (self.main_layer_zoom_scale > self.main_layer_zoom_scalemax) self.main_layer_zoom_scale = self.main_layer_zoom_scalemax
  else if (self.main_layer_zoom_scale < self.main_layer_zoom_scalemin) self.main_layer_zoom_scale = self.main_layer_zoom_scalemin

  // This is the magic. I didn't write this, but it is what allows the zoom to work.
  self.main_layer_zoom_offset_x = (self.main_layer_zoom_offset_x - pos.x) * (self.main_layer_zoom_scale / oldScale) + pos.x
  self.main_layer_zoom_offset_y = (self.main_layer_zoom_offset_y - pos.y) * (self.main_layer_zoom_scale / oldScale) + pos.y

  // Set the position and scale of the DisplayObjectContainer
  self.stage.scale.set(self.main_layer_zoom_scale, self.main_layer_zoom_scale)
  self.stage.position.set(self.main_layer_zoom_offset_x, self.main_layer_zoom_offset_y)
}

/**
 * Main Loop for graphic drawing
 */
NeuroCanvas.prototype.renderLoop = function () {
  var self = this
  if (self.holdedKey === 17 && self.canvasState === CANVAS_STATE.view) {
    self.canvasState = CANVAS_STATE.edit
    self.container.style.cursor = 'cell'
    // document.body.style.background = '#eeeeee'
    console.log('state Change ' + self.canvasState)
  } else if (self.holdedKey !== 17 && self.canvasState === CANVAS_STATE.edit) {
    self.canvasState = CANVAS_STATE.view
    self.container.style.cursor = ''
    // document.body.style.background = '#ffffff'
    console.log('state Change ' + self.canvasState)
  }

  self.neuralNetwork.neuronData.nodes.forEach(function (node) {
    if (!node.sprite) {
      node.sprite = self.createNeuron(node.x, node.y, self.nodeClip, node)
    } else {
      node.sprite.clear()
      // node 객체에 저장된 좌표를 그래프 캔버스에 적용한다.
      node.sprite.position = new PIXI.Point(node.x, node.y)
      node.sprite.lineStyle(1.5, 0xFFFFFF)
      node.sprite.beginFill(neuronGroupColor(node.group), 0.9)
      node.sprite.drawCircle(0, 0, 15)
      node.sprite.endFill()
    }
    // node.actvalue가 변하면 화면에서 노드에 표시가 되게 만들기
    if (node.actvalue) {
      var actweight = Math.abs(node.actvalue) < 2 ? Math.abs(node.actvalue) : 2
      var actcolor = node.actvalue > 0 ? 0xDDAAAA : 0x4444AA
      node.sprite.lineStyle(0, 0xFFFFFF)
      node.sprite.beginFill(actcolor, 1)
      node.sprite.drawCircle(0, 0, actweight * 5)
      node.sprite.endFill()
    }
    if (self.selectedNode) {
      if (node === self.selectedNode) {
        node.sprite.alpha = 1
      } else {
        node.sprite.alpha = 0.4
      }
    } else {
      node.sprite.alpha = 1
    }
  })
  // 라인을 새로 그린다.
  self.neuralNetwork.neuronData.links.forEach(function (link) {
    if (!link.sprite) {
      link.sprite = self.createRoute(link.source, link.target, self.linkClip, link)
    } else {
      link.sprite.clear()
      var from = self.neuralNetwork.getNode(link.source)
      var to = self.neuralNetwork.getNode(link.target)
      if (!from || !to) return console.log('invalid link data')
      link.sprite.rotation = 0
      var dx = to.x - from.x
      var dy = to.y - from.y
      var dist = Math.sqrt(dx * dx + dy * dy)
      var angle = Math.atan2(dy, dx)
      drawArrow(link.sprite, dist, link.value)
      link.sprite.x = from.x
      link.sprite.y = from.y
      link.sprite.rotation = angle
      link.sprite.alpha = 0.6
    }
  })

  self.tempArrow.clear()
  if (self.selectedNode && self.tempArrow.data && self.draggingArrow) {
    var pos = self.tempArrow.data.getLocalPosition(self.stage)
    var dx = pos.x - self.selectedNode.x
    var dy = pos.y - self.selectedNode.y
    var dist = Math.sqrt(dx * dx + dy * dy)
    if (dist < 35) return

    var angle = Math.atan2(dy, dx)
    drawArrow(self.tempArrow, dist, 2, 0x444444)
    self.tempArrow.x = self.selectedNode.x
    self.tempArrow.y = self.selectedNode.y
    self.tempArrow.rotation = angle
  }

  self.renderer.render(self.stage)
}

/**
 * Create Neuron node
 */
NeuroCanvas.prototype.createNeuron = function (x, y, stage, neuron) {
  var self = this
  stage = stage || this.nodeClip
  // create our Neuron sprite
  var sprite = new PIXI.Graphics()
  sprite.lineStyle(1.5, 0xFFFFFF)
  sprite.beginFill(neuronGroupColor(neuron.group), 0.8)
  sprite.drawCircle(0, 0, 15)
  sprite.endFill()
  // enable the Neuron sprite to be interactive... this will allow it to respond to mouse and touch events
  sprite.interactive = true
  // this button mode will mean the hand cursor appears when you roll over the bunny with your mouse
  sprite.buttonMode = true
  // sprite.scale.set(3);
  sprite.neuronID = neuron.id
  sprite.prevGroup = neuron.group

  // the pointer events takes mouse + touch events
  sprite
      .on('pointerdown', function (event) {
        if (self.canvasState === CANVAS_STATE.view) {
          self.onViewModeNeuronDragStart(this, event)
        } else if (self.canvasState === CANVAS_STATE.edit) {
          self.onEditModeNeuronDragStart(this, event)
        }
      })
      .on('pointerup', function (event) {
        if (self.canvasState === CANVAS_STATE.view) {
          self.onViewModeNeuronDragEnd(this, event)
        } else if (self.canvasState === CANVAS_STATE.edit) {
          self.onEditModeNeuronDragEnd(this, event)
        }
      })
      .on('pointerupoutside', function (event) {
        if (self.canvasState === CANVAS_STATE.view) {
          self.onViewModeNeuronDragEnd(this, event)
        } else if (self.canvasState === CANVAS_STATE.edit) {
          self.onEditModeNeuronDragEnd(null, event)
        }
      })
      .on('pointermove', function (event) {
        if (self.canvasState === CANVAS_STATE.view) {
          self.onViewModeNeuronDragMove(this, event)
        }
      })
      // For mouse-only events, use mouse*
      // For touch-only events, use touch*

  // move the sprite to its designated position
  sprite.x = x
  sprite.y = y
  // add it to the stage
  stage.addChild(sprite)
  return sprite
}

NeuroCanvas.prototype.onViewModeNeuronDragStart = function (sprite, event) {
  var self = this
  // store a reference to the data, the reason for this is because of multitouch
  // we want to track the movement of this particular touch
  sprite.data = event.data
  self.selectedNode = self.neuralNetwork.getNode(sprite.neuronID)
  sprite.dragging = true
  self.draggingSprite = true
}
NeuroCanvas.prototype.onViewModeNeuronDragEnd = function (sprite, event) {
  var self = this
  if (sprite.dragging) { // sync neuron position when drag end.
    var newPosition = sprite.data.getLocalPosition(sprite.parent)
    var node = self.neuralNetwork.getNode(sprite.neuronID)
    var nodeData = {
      id: node.id,
      x: newPosition.x,
      y: newPosition.y
    }
    self.neuralNetwork.updateNode(nodeData, true)
  }
  sprite.dragging = false
  if (sprite.data === event.data) {
    self.selectedNode = self.neuralNetwork.getNode(sprite.neuronID)
    self.emit('neuronSelected', self.selectedNode.id)
  } else {
    self.selectedNode = null
  }
  // set the interaction data to null
  sprite.data = null
  self.pointerupTracker = true // instead of event.stopPropagation()
  self.draggingSprite = false
}
NeuroCanvas.prototype.onViewModeNeuronDragMove = function (sprite, event) {
  var self = this
  if (sprite.dragging) {
    var newPosition = sprite.data.getLocalPosition(sprite.parent)
    var node = self.neuralNetwork.getNode(sprite.neuronID)
    node.x = newPosition.x
    node.y = newPosition.y
    // var nodeData = { // do not sync when neuron is in dragging. For less traffic.
    //   id: node.id,
    //   x: newPosition.x,
    //   y: newPosition.y
    // }
    // self.neuralNetwork.updateNode(nodeData, true)
  }
}

NeuroCanvas.prototype.onEditModeNeuronDragStart = function (sprite, event) {
  var self = this
  self.selectedNode = self.neuralNetwork.getNode(sprite.neuronID)
  self.tempArrow.data = event.data
  self.draggingArrow = true
}
NeuroCanvas.prototype.onEditModeNeuronDragEnd = function (sprite, event) {
  var self = this
  self.draggingArrow = false
  if (!self.selectedNode || !sprite) return
  var node = self.neuralNetwork.getNode(sprite.neuronID)
  if (self.selectedNode !== node) {
    // create new route
    var linkData = { source: self.selectedNode.id, target: node.id }
    var checkExist = self.neuralNetwork.getLink(linkData.source, linkData.target)
    if (checkExist) {
      console.log('route already exist')
      return
    }
    self.neuralNetwork.addLink(linkData, true)
    var routedata = self.neuralNetwork.getLink(linkData.source, linkData.target)
    linkData.sprite = self.createRoute(linkData.source, linkData.target, self.linkClip, routedata)
  }
}
// NeuroCanvas.prototype.onEditModeNeuronDragMove = function (sprite, event) {
//   var self = this
// }

/**
 * Create Neuron Route Arrow
 */
NeuroCanvas.prototype.createRoute = function (sourceId, targetId, stage, route) {
  var self = this
  stage = stage || this.linkClip

  var source = self.neuralNetwork.getNode(sourceId)
  var target = self.neuralNetwork.getNode(targetId)
  if (!source || !target) return

  // create our Neuron sprite
  var sprite = new PIXI.Graphics()
  var dx = target.x - source.x
  var dy = target.y - source.y
  var dist = Math.sqrt(dx * dx + dy * dy)
  var angle = Math.atan2(dy, dx)
  // sprite.beginFill(0xAAAAAA, 0)
  drawArrow(sprite, dist, route.value)
  sprite.interactive = true
  sprite.buttonMode = true
  sprite.routeID = route.source + TO + route.target

  // the pointer events takes mouse + touch events
  sprite
     .on('pointerdown', function (event) {
       if (self.canvasState === CANVAS_STATE.view) {
         self.onViewModeDragArrowStart(this, event)
       }
       event.stopPropagation()
     })
     .on('pointerup', function (event) {
       if (self.canvasState === CANVAS_STATE.view) {
         self.onViewModeDragArrowEnd(this, event)
       }
     })
     .on('pointerupoutside', function (event) {
       if (self.canvasState === CANVAS_STATE.view) {
         self.onViewModeDragArrowEnd(this, event)
       }
     })
     .on('pointermove', function (event) {
       if (self.canvasState === CANVAS_STATE.view) {
         // self.onViewModeDragArrowMove(this, event)
       }
     })
     // For mouse-only events, use mouse*
     // For touch-only events, use touch*

  // move the sprite to its designated position
  sprite.x = source.x
  sprite.y = source.y
  sprite.rotation = angle
  // add it to the stage
  stage.addChild(sprite)
  return sprite
}
NeuroCanvas.prototype.onViewModeDragArrowStart = function (sprite, event) {
  var self = this
  self.selectedLink = null
  sprite.data = event.data
}
NeuroCanvas.prototype.onViewModeDragArrowEnd = function (sprite, event) {
  var self = this
  if (sprite.data === event.data && sprite.data) {
    self.selectedLink = self.neuralNetwork.getLink(sprite.routeID)
    self.selectedNode = self.neuralNetwork.getNode(self.selectedLink.target)
    self.emit('neuronSelected', self.selectedNode.id)
  } else {
    self.selectedLink = null
  }
}
NeuroCanvas.prototype.keydown = function (event) {
  var self = this
  // event.preventDefault()

  if (self.holdedKey !== -1) {
    self.holdedKey = -1
    return
  }
  self.holdedKey = event.keyCode

  // ctrl
  if (self.holdedKey === 17) {
  }

  if (!self.selectedNode && !self.selectedLink) return

  switch (self.holdedKey) {
    case 8: // backspace
    case 46: // delete
      if (self.selectedNode) {
        self.nodeClip.removeChild(self.selectedNode.sprite)
        self.neuroPanel.recieveNodeChange({
          type: 'delete',
          value: { id: self.selectedNode.id }
        })
        self.neuralNetwork.deleteNode({
          id: self.selectedNode.id
        }, true)
        for (var i = self.neuralNetwork.neuronData.links.length - 1; i >= 0; i--) {
          var link = self.neuralNetwork.neuronData.links[i]
          if (link.source === self.selectedNode.id || link.target === self.selectedNode.id) {
            self.linkClip.removeChild(link.sprite)
            self.neuroPanel.recieveNodeChange({
              type: 'delete',
              value: {
                source: link.source,
                target: link.target
              }
            })
            self.neuralNetwork.deleteLink({
              source: link.source,
              target: link.target
            }, true)
          }
        }
      } else if (self.selectedLink) {
        // self.neuralNetwork.neuronData.links.splice(self.neuralNetwork.neuronData.links.indexOf(self.selectedLink), 1)
        self.linkClip.removeChild(self.selectedLink.sprite)
        self.neuroPanel.recieveNodeChange({
          type: 'delete',
          value: {
            source: link.source,
            target: link.target
          }
        })
        self.neuralNetwork.deleteLink({
          source: self.selectedLink.source,
          target: self.selectedLink.target
        }, true)
      }
      self.selectedLink = null
      self.selectedNode = null
      break
    case 66: // B
      break
    case 76: // L
      break
    case 82: // R
      break
  }
}

NeuroCanvas.prototype.keyup = function (event) {
  var self = this
  // ctrl
  if (self.holdedKey === 17) {
  }
  self.holdedKey = -1
}

NeuroCanvas.prototype.syncDeleteNeuron = function (data) {
  var self = this
  var node = self.neuralNetwork.getNode(data.id)
  self.nodeClip.removeChild(node.sprite)
}

NeuroCanvas.prototype.syncDeleteRoute = function (data) {
  var self = this
  var link = self.neuralNetwork.getLink(data.source, data.target)
  self.linkClip.removeChild(link.sprite)
}
/**
 * Utility
*/
function drawArrow (context, dist, value, color) { // create Arrow graphic
  var headlen = 15 // length of head in pixels
  // calculate margin of arrow from node.
  var sourcePadding = 18
  var targetPadding = 20
  // draw arrow body
  color = color || ((value > 0) ? 0xFF0000 : 0x0000FF)
  var visVal = Math.abs(value) * 4 + 1
  if (visVal > 8) visVal = 8
  else if (visVal < 2) visVal = 2
  context.lineStyle(0)
  context.beginFill(color)
  context.moveTo(sourcePadding, 0 - visVal / 2)
  context.lineTo(dist - targetPadding - headlen + 2, 0 - visVal / 2)
  context.lineTo(dist - targetPadding - headlen + 2, 0 + visVal / 2)
  context.lineTo(sourcePadding, 0 + visVal / 2)
  context.moveTo(sourcePadding, 0 - visVal / 2)
  context.endFill()
  // draw arrow head
  context.lineStyle(0)
  context.beginFill(color)
  context.moveTo(dist - targetPadding, 0)
  context.lineTo(dist - targetPadding - headlen * Math.cos(0 - Math.PI / 6), headlen * Math.sin(0 - Math.PI / 6))
  context.lineTo(dist - targetPadding - headlen * Math.cos(0 + Math.PI / 6), headlen * Math.sin(0 + Math.PI / 6))
  context.lineTo(dist - targetPadding, 0)
  context.endFill()
}

function neuronGroupColor (value) {
  if (value === 'input') {
    return '0xFF0000'
  } else if (value === 'output') {
    return '0x0000FF'
  } else if (value === 'selftrain') {
    return '0xEEEEEE'
  } else {
    var number = parseInt(value) * (359 / 11)
    var color = hslToHexColor(number, 100, 65, '0x')
    return color
  }
}
/**
 * Detect the amount of distance the wheel has traveled and normalize it based on browsers.
 * @param  event
 * @return integer
 */
// function wheelDistance (event) {
//   var w = event.wheelDelta
//   var d = event.detail
//   if (d) {
//     if (w) return w / d / 40 * d > 0 ? 1 : -1 // Opera
//     else return -d / 3 // Firefox;         TODO: do not /3 for OS X
//   } else return w / 120 // IE/Safari/Chrome TODO: /3 for Chrome OS X
// }

/**
 * Detect the direction that the scroll wheel moved
 * @param event
 * @return integer
 */
function wheelDirection (event) {
  return (event.detail < 0) ? 1 : (event.wheelDelta > 0) ? 1 : -1
}

module.exports = NeuroCanvas

},{"./hsl":23,"./util":28,"events":30,"inherits":2}],27:[function(require,module,exports){
var util = require('./util')

// Neuro Control panel
var CONTROL_STATE = {
  default: 'default',
  neuron: 'neuron',
  route: 'route'
}
var DOMID_TO_NODE = {
  neuronID: 'id',
  neuronGroup: 'group',
  sumOfWeight: 'sumofw',
  bias: 'bias',
  activateMethod: 'actMethod',
  activatedValue: 'actvalue'
}

// Game Setting
var TetrisGame = require('./game/tetris/drawing')
var XorGame = require('./game/xor/drawing')
var DynamicOutputGame = require('./game/dynamicout/drawing')
var FlappyBirdGame = require('./game/fbird/drawing')
var ENV_LIST = {
  'tetris': TetrisGame,
  'dynamicout': DynamicOutputGame,
  'xor': XorGame,
  'flappybird': FlappyBirdGame
}

function NeuroPanel (options) {
  var self = this
  self.container = options.container
  self.neuralNetwork = options.neuralNetwork
  self.inputGameDom = options.inputGameDom
  self.state = CONTROL_STATE.default

  self.selectedNeuron = null
  self.neuronEventBinder = null

  self.tdid = Math.random().toString(8).substr(2)

  var oldom = document.createElement('ol')
  var liTraningDom = document.createElement('li')
  var liNeuronDom = document.createElement('li')
  oldom.appendChild(liTraningDom)
  oldom.appendChild(liNeuronDom)
  self.container.appendChild(oldom)

  /*
  * Panel Train DOM
  */
  var tabcheck = pushElement(liTraningDom, 'input', {
    class: 'Tab-Train tab',
    type: 'checkbox',
    checked: true
  })
  var tablabel = pushElement(liTraningDom, 'label', {
    class: 'panel-tab-label',
    innerText: 'Training'
  })
  tablabel.addEventListener('click', function (e) {
    tabcheck.checked = !tabcheck.checked
  })
  var panelTrainWrap = pushElement(liTraningDom, 'div', {
    class: 'panel-content'
  })

  var panelTrainInputGame = pushElement(panelTrainWrap, 'div', { class: 'panel-row' })
  pushElement(panelTrainInputGame, 'label', {
    for: 'inputGame' + self.tdid,
    title: 'inputGame',
    innerText: 'Input Game'
  })
  var panelTrainInputGameForm = pushElement(panelTrainInputGame, 'div', { class: 'panel-row-form' })
  self.ifaceInputGame = pushElement(panelTrainInputGameForm, 'select', {
    id: 'inputGame' + self.tdid,
    class: 'form-control input-sm',
    innerHTML: '<option value="dynamicout">dynamicout</option>' +
    '<option value="tetris">tetris</option>' +
    '<option value="xor">xor</option>' +
    '<option value="flappybird">flappybird</option>'
  })

  var panelTrainRowLearningRate = pushElement(panelTrainWrap, 'div', { class: 'panel-row' })
  pushElement(panelTrainRowLearningRate, 'label', {
    for: 'learningRate' + self.tdid,
    title: 'learningRate',
    innerText: 'Learning Rate'
  })
  var panelTrainRowLearningRateForm = pushElement(panelTrainRowLearningRate, 'div', { class: 'panel-row-form' })
  self.ifaceLearningRate = pushElement(panelTrainRowLearningRateForm, 'input', {
    id: 'learningRate' + self.tdid,
    type: 'range',
    min: 0,
    max: 1,
    step: 0.001,
    value: 0.01
  })
  self.ifaceLearningRateValue = pushElement(panelTrainRowLearningRateForm, 'input', {
    id: 'learningRateValue' + self.tdid,
    type: 'text',
    value: 0.01,
    disabled: true
  })
  self.ifaceLearningRate.addEventListener('change', function (event) {
    self.ifaceLearningRateValue.value = event.target.value
  })

  // self.ifaceTargetGroup = document.getElementById('targetGroup')
  var panelTrainRowtargetGroup = pushElement(panelTrainWrap, 'div', { class: 'panel-row' })
  pushElement(panelTrainRowtargetGroup, 'label', {
    for: 'targetGroup' + self.tdid,
    title: 'targetGroup',
    innerText: 'Target Group'
  })
  var panelTrainRowtargetGroupForm = pushElement(panelTrainRowtargetGroup, 'div', { class: 'panel-row-form' })
  self.ifaceTargetGroup = pushElement(panelTrainRowtargetGroupForm, 'select', {
    id: 'targetGroup' + self.tdid,
    class: 'form-control input-sm',
    innerHTML: '<option value="input">Input</option><option value="output">Output</option> <option value="selftrain">Self Train</option> <option value="1">1</option> <option value="2">2</option> <option value="3">3</option> <option value="4">4</option> <option value="5">5</option><option value="6">6</option> <option value="7">7</option> <option value="8">8</option> <option value="9">9</option> <option value="10">10</option> <option value="selftrain">Self Train</option> <option value="all">All</option>'
  })

  // self.ifaceRouteDirection = document.getElementById('routeDirection')
  var panelTrainrouteDirection = pushElement(panelTrainWrap, 'div', { class: 'panel-row' })
  pushElement(panelTrainrouteDirection, 'label', {
    for: 'routeDirection' + self.tdid,
    title: 'routeDirection',
    innerText: 'Route Direction'
  })
  var panelTrainrouteDirectionForm = pushElement(panelTrainrouteDirection, 'div', { class: 'panel-row-form' })
  self.ifaceRouteDirection = pushElement(panelTrainrouteDirectionForm, 'select', {
    id: 'routeDirection' + self.tdid,
    class: 'form-control input-sm',
    innerHTML: '<option value="from">From</option><option value="to">To</option><option value="both">Both</option>'
  })

  // self.ifaceApplyRandomWeight = document.getElementById('applyRandomWeight')
  var panelTrainApplyRandomWeight = pushElement(panelTrainWrap, 'div', { class: 'panel-row' })
  pushElement(panelTrainApplyRandomWeight, 'label', {
    for: 'applyRandomWeight' + self.tdid,
    title: 'applyRandomWeight',
    innerText: 'Random weight'
  })
  var panelTrainApplyRandomWeightForm = pushElement(panelTrainApplyRandomWeight, 'div', { class: 'panel-row-form' })
  self.ifaceApplyRandomWeight = pushElement(panelTrainApplyRandomWeightForm, 'input', {
    id: 'applyRandomWeight' + self.tdid,
    type: 'button',
    value: 'Distract it'
  })

  // self.ifaceApplyAccelerateWeight = document.getElementById('applyAccelerateWeight')
  var panelTrainApplyAccelerateWeight = pushElement(panelTrainWrap, 'div', { class: 'panel-row' })
  pushElement(panelTrainApplyAccelerateWeight, 'label', {
    for: 'applyAccelerateWeight' + self.tdid,
    title: 'applyAccelerateWeight',
    innerText: 'Accelerate Weight'
  })
  var panelTrainApplyAccelerateWeightForm = pushElement(panelTrainApplyAccelerateWeight, 'div', { class: 'panel-row-form' })
  self.ifaceApplyAccelerateWeight = pushElement(panelTrainApplyAccelerateWeightForm, 'input', {
    id: 'applyAccelerateWeight' + self.tdid,
    type: 'button',
    value: 'Encourage it'
  })

  // self.ifaceProcessState = document.getElementById('processState')
  var panelTrainApplyProcessState = pushElement(panelTrainWrap, 'div', { class: 'panel-row' })
  pushElement(panelTrainApplyProcessState, 'label', {
    for: 'processState' + self.tdid,
    title: 'processState',
    innerText: 'Process State'
  })
  var panelTrainApplyProcessStateForm = pushElement(panelTrainApplyProcessState, 'div', { class: 'panel-row-form' })
  self.ifaceProcessState = pushElement(panelTrainApplyProcessStateForm, 'input', {
    id: 'processState' + self.tdid,
    type: 'checkbox',
    style: 'float:left;'
  })
  panelTrainApplyProcessStateForm.insertAdjacentHTML('beforeend', '<div style="color:#888;display:inline-block;float:left;margin:2px 0 0 6px;"><span>Check to start</span></div>')

  // self.ifaceSaveAsJSON = document.getElementById('saveAsJSON')
  var panelTrainSaveAsJSON = pushElement(panelTrainWrap, 'div', { class: 'panel-row' })
  pushElement(panelTrainSaveAsJSON, 'label', {
    for: 'saveAsJSON' + self.tdid,
    title: 'saveAsJSON',
    innerText: 'Print JSON on Console'
  })
  var panelTrainSaveAsJSONForm = pushElement(panelTrainSaveAsJSON, 'div', { class: 'panel-row-form' })
  self.ifaceSaveAsJSON = pushElement(panelTrainSaveAsJSONForm, 'input', {
    id: 'saveAsJSON' + self.tdid,
    type: 'button',
    value: 'JSON Stringify'
  })

  self.neuronEventBinder = self.neuronEventHandler.bind(self)

  /*
  * Panel Neuron DOM
  */
  self.tabNeuron = pushElement(liNeuronDom, 'input', {
    class: 'Tab-Neuron tab',
    type: 'checkbox',
    checked: false
  })
  var tabNeuronlabel = pushElement(liNeuronDom, 'label', {
    class: 'panel-tab-label',
    innerText: 'Neuron'
  })
  tabNeuronlabel.addEventListener('click', function (e) {
    self.tabNeuron.checked = !self.tabNeuron.checked
  })
  var panelNeuronWrap = pushElement(liNeuronDom, 'div', {
    class: 'panel-content'
  })
  pushElement(panelNeuronWrap, 'h4', { innerText: 'Neuron Config' })

  // self.ifaceNeuronID = document.getElementById('neuronID')
  var panelNeuronID = pushElement(panelNeuronWrap, 'div', { class: 'panel-row' })
  pushElement(panelNeuronID, 'label', {
    for: 'neuronID' + self.tdid,
    title: 'neuronID',
    innerText: 'Neuron ID'
  })
  var panelNeuronIDForm = pushElement(panelNeuronID, 'div', { class: 'panel-row-form' })
  self.ifaceNeuronID = pushElement(panelNeuronIDForm, 'input', {
    id: 'neuronID' + self.tdid,
    type: 'text',
    value: 'id',
    disabled: true
  })

  // self.ifaceNeuronGroup = document.getElementById('neuronGroup')
  var panelNeuronGroup = pushElement(panelNeuronWrap, 'div', { class: 'panel-row' })
  pushElement(panelNeuronGroup, 'label', {
    for: 'neuronGroup' + self.tdid,
    title: 'neuronGroup',
    innerText: 'Neuron Group'
  })
  var panelNeuronGroupForm = pushElement(panelNeuronGroup, 'div', { class: 'panel-row-form' })
  self.ifaceNeuronGroup = pushElement(panelNeuronGroupForm, 'select', {
    id: 'neuronGroup' + self.tdid,
    class: 'form-control input-sm',
    innerHTML: '<option value="input">Input</option><option value="output">Output</option> <option value="selftrain">Self Train</option>' +
      '<option value="1">1</option><option value="2">2</option><option value="3">3</option><option value="4">4</option><option value="5">5</option>' +
      '<option value="6">6</option><option value="7">7</option><option value="8">8</option><option value="9">9</option><option value="10">10</option>'
  })

  // self.ifaceSumOfWeight = document.getElementById('sumOfWeight')
  var panelNeuronSOW = pushElement(panelNeuronWrap, 'div', { class: 'panel-row' })
  pushElement(panelNeuronSOW, 'label', {
    for: 'sumOfWeight' + self.tdid,
    title: 'sumOfWeight',
    innerText: 'Sum Of Weight'
  })
  var panelNeuronSOWForm = pushElement(panelNeuronSOW, 'div', { class: 'panel-row-form' })
  self.ifaceSumOfWeight = pushElement(panelNeuronSOWForm, 'input', {
    id: 'sumOfWeight' + self.tdid,
    type: 'text',
    value: '0',
    disabled: true
  })

  // self.ifaceBias = document.getElementById('bias')
  var panelNeuronBias = pushElement(panelNeuronWrap, 'div', { class: 'panel-row' })
  pushElement(panelNeuronBias, 'label', {
    for: 'bias' + self.tdid,
    title: 'bias',
    innerText: 'Bias'
  })
  var panelNeuronBiasForm = pushElement(panelNeuronBias, 'div', { class: 'panel-row-form' })
  self.ifaceBias = pushElement(panelNeuronBiasForm, 'input', {
    id: 'bias' + self.tdid,
    type: 'text',
    value: '0'
  })

  // self.ifaceActivateMethod = document.getElementById('activateMethod')
  var panelNeuronActivateMethod = pushElement(panelNeuronWrap, 'div', { class: 'panel-row' })
  pushElement(panelNeuronActivateMethod, 'label', {
    for: 'activateMethod' + self.tdid,
    title: 'activateMethod',
    innerText: 'Neuron ID'
  })
  var panelNeuronActivateMethodForm = pushElement(panelNeuronActivateMethod, 'div', { class: 'panel-row-form' })
  self.ifaceActivateMethod = pushElement(panelNeuronActivateMethodForm, 'select', {
    id: 'activateMethod' + self.tdid,
    class: 'form-control input-sm',
    innerHTML: '<option value="identity">identity</option><option value="relu">ReLu</option><option value="sigmoid">Sigmoid</option><option value="thresold">thresold</option>'
  })

  // self.ifaceActivatedValue = document.getElementById('activatedValue')
  var panelNeuronActivatedValue = pushElement(panelNeuronWrap, 'div', { class: 'panel-row' })
  pushElement(panelNeuronActivatedValue, 'label', {
    for: 'activatedValue' + self.tdid,
    title: 'activatedValue',
    innerText: 'Neuron ID'
  })
  var panelNeuronActivatedValueForm = pushElement(panelNeuronActivatedValue, 'div', { class: 'panel-row-form' })
  self.ifaceActivatedValue = pushElement(panelNeuronActivatedValueForm, 'input', {
    id: 'activatedValue' + self.tdid,
    type: 'text',
    value: '0',
    disabled: true
  })

  /*
  * Neuron Routes DOM
  */
  pushElement(panelNeuronWrap, 'h4', { innerText: 'Neuron Routes' })
  self.routeContainer = pushElement(panelNeuronWrap, 'div', { class: 'NeuronRoutes' })

  self.ifaceNeuronGroup.addEventListener('change', self.neuronEventBinder)
  self.ifaceSumOfWeight.addEventListener('change', self.neuronEventBinder)
  self.ifaceBias.addEventListener('keyup', self.neuronEventBinder)
  self.ifaceActivateMethod.addEventListener('change', self.neuronEventBinder)
  self.ifaceActivatedValue.addEventListener('change', self.neuronEventBinder)

  var token = true
  self.mutualExcluse = function (f) {
    if (token) {
      token = false
      try {
        f()
      } catch (e) {
        token = true
        throw new Error(e)
      }
      token = true
    }
  }
}
NeuroPanel.prototype.initPanel = function (env) {
  var self = this

  if (!env) env = 'dynamicout'
  var GameScene = ENV_LIST[env]
  if (!GameScene) return

  self.ifaceInputGame.value = env
  self.gameScene = new GameScene({ width: 170, height: 230, container: self.inputGameDom })
  self.gameSceneLoop = self.gameScene.gameLoop.bind(self.gameScene)
  util.loopProcess.addProcess(self.gameSceneLoop)

  self.ifaceLearningRate.value = self.ifaceLearningRateValue.value = self.neuralNetwork.learningRate
  self.ifaceSaveAsJSON.addEventListener('click', function (e) {
    console.log(JSON.stringify(self.neuralNetwork.saveAsJSON()))
  })
  self.ifaceApplyRandomWeight.addEventListener('click', function (e) {
    self.neuralNetwork.applyRandomWeight(self.ifaceLearningRate.value, self.ifaceTargetGroup.value, self.ifaceRouteDirection.value)
  })
  self.ifaceApplyAccelerateWeight.addEventListener('click', function (e) {
    self.neuralNetwork.applyAccelerateWeight(self.ifaceLearningRate.value, self.ifaceTargetGroup.value, self.ifaceRouteDirection.value)
  })

  self.ifaceInputGame.addEventListener('click', function (e) {
    var GameScene = ENV_LIST[self.ifaceInputGame.value]
    if (!GameScene) return

    if (self.gameSceneLoop) {
      util.loopProcess.removeProcess(self.gameSceneLoop)
      if (self.gameScene.destroy) self.gameScene.destroy()
      // TODO: game destroy 만들기
      self.inputGameDom.removeChild(self.gameScene.renderer.view)
    }
    self.gameScene = new GameScene({ width: 170, height: 230, container: self.inputGameDom })
    self.gameSceneLoop = self.gameScene.gameLoop.bind(self.gameScene)
    util.loopProcess.addProcess(self.gameSceneLoop)
  })
  self.nturn = 0
  function nnloop (delta) {
    var self = this
    self.nturn = (self.nturn + 1) % 12 // frame skip
    if (self.nturn === 0) {
      var inputdata = self.gameScene.getEnvironmentData()
      var outputdata = self.neuralNetwork.getOutput()
      self.neuralNetwork.process(inputdata)
      self.gameScene.pushAction(outputdata)
      self.neuralNetwork.selfTraining(self.ifaceLearningRate.value)
    }
  }
  self.nnloop = nnloop.bind(self)
  self.ifaceProcessState.addEventListener('click', function (e) {
    // set main loop method
    if (e.target.checked) util.loopProcess.addProcess(self.nnloop)
    else util.loopProcess.removeProcess(self.nnloop)
  })
}

NeuroPanel.prototype.selectNeuron = function (nodeID) {
  var self = this
  self.selectedNeuron = self.neuralNetwork.getNode(nodeID)
  if (!self.selectedNeuron) return
  // init neuron section
  self.tabNeuron.checked = true

  if (!self.selectedNeuron.group) self.selectedNeuron.group = 0
  if (!self.selectedNeuron.sumofw) self.selectedNeuron.sumofw = 0
  if (!self.selectedNeuron.bias) self.selectedNeuron.bias = 0
  if (!self.selectedNeuron.actMethod) self.selectedNeuron.actMethod = 'identity'
  if (!self.selectedNeuron.actvalue) self.selectedNeuron.actvalue = 0

  self.ifaceNeuronID.value = self.selectedNeuron.id
  self.ifaceNeuronGroup.value = self.selectedNeuron.group
  self.ifaceSumOfWeight.value = self.selectedNeuron.sumofw
  self.ifaceBias.value = self.selectedNeuron.bias
  self.ifaceActivateMethod.value = self.selectedNeuron.actMethod
  self.ifaceActivatedValue.value = self.selectedNeuron.actvalue

  while (self.routeContainer.firstChild) {
    self.routeContainer.removeChild(self.routeContainer.firstChild)
  }
  self.neuralNetwork.neuronData.links.forEach(function (link) {
    if (link.target === self.selectedNeuron.id) {
      self.createRouteRow(link, 'from')
    }
  })
  if (self.routeContainer.firstChild) {
    var rowdivider = document.createElement('div')
    rowdivider.className = 'panel-row divider'
    self.routeContainer.appendChild(rowdivider)
  }
  self.neuralNetwork.neuronData.links.forEach(function (link) {
    if (link.source === self.selectedNeuron.id) {
      self.createRouteRow(link, 'to')
    }
  })
}

NeuroPanel.prototype.createRouteRow = function (link, direction) {
  var self = this

  var dest = ((direction === 'from') ? link.source : link.target)

  var row = document.createElement('div')
  row.className = 'panel-row'
  self.routeContainer.appendChild(row)

  var label = document.createElement('label')
  label.setAttribute('for', 'route-' + link.source + '-' + link.target)
  label.setAttribute('title', 'route-' + link.source + '-' + link.target)
  label.innerText = 'Weight ' + direction + ' '// + dest
  row.appendChild(label)

  var formcon = document.createElement('div')
  formcon.className = 'panel-row-form'
  row.appendChild(formcon)

  var inputnid = document.createElement('input')
  inputnid.setAttribute('type', 'text')
  inputnid.setAttribute('value', dest)
  inputnid.setAttribute('disabled', 'true')
  inputnid.id = 'route-' + link.source + '-' + link.target + direction
  formcon.appendChild(inputnid)

  var inputrange = document.createElement('input')
  inputrange.setAttribute('type', 'range')
  inputrange.setAttribute('min', '-2')
  inputrange.setAttribute('max', '2')
  inputrange.setAttribute('step', '0.001')
  inputrange.setAttribute('value', link.value)
  inputrange.id = 'route-' + link.source + '-' + link.target
  formcon.appendChild(inputrange)
  inputrange.addEventListener('change', self.routeEventHandler.bind(self))

  var inputval = document.createElement('input')
  inputval.setAttribute('type', 'text')
  inputval.setAttribute('value', link.value)
  inputval.setAttribute('disabled', 'true')
  inputval.id = 'route-' + link.source + '-' + link.target + 'value'
  formcon.appendChild(inputval)

  inputrange.addEventListener('change', function (event) {
    inputval.value = event.target.value
  })
}

NeuroPanel.prototype.neuronEventHandler = function (event) {
  var self = this
  if (!self.selectedNeuron) return
  self.mutualExcluse(function () {
    var outputObj = { id: self.selectedNeuron.id }
    console.log('neuronEventHandler: ' + DOMID_TO_NODE[String(event.target.id).replace(self.tdid, '')])
    outputObj[DOMID_TO_NODE[String(event.target.id).replace(self.tdid, '')]] = event.target.value
    self.neuralNetwork.updateNode(outputObj, true)
  })
}
NeuroPanel.prototype.routeEventHandler = function (event) {
  var self = this
  if (!self.selectedNeuron) return
  self.mutualExcluse(function () {
    var temArr = event.target.id.split('-')
    var selectedlink = self.neuralNetwork.getLink(temArr[1], temArr[2])
    if (selectedlink) {
      var outputObj = {
        source: temArr[1],
        target: temArr[2],
        delta: event.target.value - selectedlink.value,
        value: event.target.value
      }
      self.neuralNetwork.updateLink(outputObj, true)
    }
  })
}

NeuroPanel.prototype.releaseNeuron = function () {
  var self = this
  self.tabNeuron.checked = false
  while (self.routeContainer.firstChild) {
    self.routeContainer.removeChild(self.routeContainer.firstChild)
  }
  self.selectedNeuron = null
}

NeuroPanel.prototype.recieveNodeChange = function (data) {
  var self = this
  self.mutualExcluse(function () {
    if (!self.selectedNeuron) return
    if (data.type === 'delete') {
      if (self.selectedNeuron.id === data.value.id) {
        self.releaseNeuron()
      }
    } else if (data.type === 'update') {
      if (self.selectedNeuron.id === data.value.id) {
        if (data.value.group) self.ifaceNeuronGroup.value = data.value.group
        if (data.value.bias) self.ifaceBias.value = data.value.bias
        if (data.value.actMethod) self.ifaceActivateMethod.value = data.value.actMethod
        if (data.value.sumofw) self.ifaceSumOfeight.value = data.value.sumofw
        if (data.value.actvalue) self.ifaceActivatedValue.value = data.value.actvalue
      }
    }
  })
}
NeuroPanel.prototype.recieveLinkChange = function (data) {
  var self = this
  self.mutualExcluse(function () {
    if (data.type === 'delete') {
      var inputnidfrom = document.getElementById('route-' + data.value.source + '-' + data.value.target + 'from')
      if (inputnidfrom) {
        inputnidfrom.parentElement.parentElement.parentElement.removeChild(inputnidfrom.parentElement.parentElement)
      }
    } else if (data.type === 'update') {
      console.log('tracking recieveNodeChange: ' + JSON.stringify(data))
      var inputrange = document.getElementById('route-' + data.value.source + '-' + data.value.target)
      var inputval = document.getElementById('route-' + data.value.source + '-' + data.value.target + 'value')
      if (inputrange && data.value.value) inputrange.value = data.value.value
      if (inputval && data.value.value) inputval.value = data.value.value
    }
  })
}

NeuroPanel.prototype.close = function () {
  var self = this
  self.ifaceNeuronGroup.removeEventListener('change', self.neuronEventBinder)
  self.ifaceSumOfWeight.removeEventListener('change', self.neuronEventBinder)
  self.ifaceBias.removeEventListener('keyup', self.neuronEventBinder)
  self.ifaceActivateMethod.removeEventListener('change', self.neuronEventBinder)
  self.ifaceActivatedValue.removeEventListener('change', self.neuronEventBinder)
}

function pushElement (parentElement, tagName, options) {
  var element = document.createElement(tagName)
  if (options) {
    if (options.id) element.id = options.id
    if (options.class) element.className = options.class
    if (options.type) element.type = options.type
    if (options.value) element.value = options.value

    if (options.checked) element.checked = options.checked
    if (options.innerHTML) element.innerHTML = options.innerHTML
    if (options.innerText) element.innerText = options.innerText
    if (options.title) element.setAttribute('title', options.title)
    if (options.disabled) element.setAttribute('disabled', options.disabled)
    if (options.min) element.setAttribute('min', options.min)
    if (options.max) element.setAttribute('max', options.max)
    if (options.step) element.setAttribute('step', options.step)
    if (options.style) element.setAttribute('style', options.style)
  }
  parentElement.appendChild(element)
  return element
}

module.exports = NeuroPanel

},{"./game/dynamicout/drawing":14,"./game/fbird/drawing":16,"./game/tetris/drawing":17,"./game/xor/drawing":22,"./util":28}],28:[function(require,module,exports){

/**
 * Request Animation Frame Setting for compatibility.
 */
window.requestAnimFrame = (function () {
  return window.requestAnimationFrame ||
    window.webkitRequestAnimationFrame ||
    window.mozRequestAnimationFrame ||
    window.msRequestAnimationFrame ||
    function (callback) {
      window.setTimeout(callback, 1000 / 60)
    }
})()
window.cancelAnimFrame = (function () {
  return window.cancelAnimationFrame || window.mozCancelAnimationFrame
})()

/**
 * Manager for Request Animation Frame.
 * Less RAF call, better performance.
 * Ref: https://stackoverflow.com/questions/17103785/multiple-requestanimationframe-performance
 */
function LoopProcess () {
  var self = this
  self.processes = []

  function animate (timestamp) {
    for (var i = 0; i < self.processes.length; i++) {
      self.processes[i]() // execute each process.
    }
    window.requestAnimFrame(animate)
  }
  window.requestAnimFrame(animate)
}
LoopProcess.prototype.addProcess = function (process) {
  var self = this
  if (typeof process === 'function') {
    if (self.processes.findIndex(function (val) { return val === process }) === -1) self.processes.push(process)
    return process
  } else console.warn('LoopProcess: Attempt to non-function var to process array!')
  return null
}
LoopProcess.prototype.removeProcess = function (process) {
  var self = this
  var pidx = self.processes.findIndex(function (targetprocess) {
    return targetprocess === process
  })
  if (pidx !== -1) {
    self.processes.splice(pidx, 1)
    return true
  }
  return false
}

function getParameterByName (name) {
  var url = window.location.href
  name = name.replace(/[\[\]]/g, '\\$&')
  var regex = new RegExp('[?&]' + name + '(=([^&#]*)|&|#|$)')
  var results = regex.exec(url)
  if (!results) return null
  if (!results[2]) return ''
  return decodeURIComponent(results[2].replace(/\+/g, ' '))
}

module.exports = {
  loopProcess: new LoopProcess(),
  getParameterByName: getParameterByName
}

},{}],29:[function(require,module,exports){

},{}],30:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var objectCreate = Object.create || objectCreatePolyfill
var objectKeys = Object.keys || objectKeysPolyfill
var bind = Function.prototype.bind || functionBindPolyfill

function EventEmitter() {
  if (!this._events || !Object.prototype.hasOwnProperty.call(this, '_events')) {
    this._events = objectCreate(null);
    this._eventsCount = 0;
  }

  this._maxListeners = this._maxListeners || undefined;
}
module.exports = EventEmitter;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
var defaultMaxListeners = 10;

var hasDefineProperty;
try {
  var o = {};
  if (Object.defineProperty) Object.defineProperty(o, 'x', { value: 0 });
  hasDefineProperty = o.x === 0;
} catch (err) { hasDefineProperty = false }
if (hasDefineProperty) {
  Object.defineProperty(EventEmitter, 'defaultMaxListeners', {
    enumerable: true,
    get: function() {
      return defaultMaxListeners;
    },
    set: function(arg) {
      // check whether the input is a positive number (whose value is zero or
      // greater and not a NaN).
      if (typeof arg !== 'number' || arg < 0 || arg !== arg)
        throw new TypeError('"defaultMaxListeners" must be a positive number');
      defaultMaxListeners = arg;
    }
  });
} else {
  EventEmitter.defaultMaxListeners = defaultMaxListeners;
}

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
  if (typeof n !== 'number' || n < 0 || isNaN(n))
    throw new TypeError('"n" argument must be a positive number');
  this._maxListeners = n;
  return this;
};

function $getMaxListeners(that) {
  if (that._maxListeners === undefined)
    return EventEmitter.defaultMaxListeners;
  return that._maxListeners;
}

EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
  return $getMaxListeners(this);
};

// These standalone emit* functions are used to optimize calling of event
// handlers for fast cases because emit() itself often has a variable number of
// arguments and can be deoptimized because of that. These functions always have
// the same number of arguments and thus do not get deoptimized, so the code
// inside them can execute faster.
function emitNone(handler, isFn, self) {
  if (isFn)
    handler.call(self);
  else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners[i].call(self);
  }
}
function emitOne(handler, isFn, self, arg1) {
  if (isFn)
    handler.call(self, arg1);
  else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners[i].call(self, arg1);
  }
}
function emitTwo(handler, isFn, self, arg1, arg2) {
  if (isFn)
    handler.call(self, arg1, arg2);
  else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners[i].call(self, arg1, arg2);
  }
}
function emitThree(handler, isFn, self, arg1, arg2, arg3) {
  if (isFn)
    handler.call(self, arg1, arg2, arg3);
  else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners[i].call(self, arg1, arg2, arg3);
  }
}

function emitMany(handler, isFn, self, args) {
  if (isFn)
    handler.apply(self, args);
  else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners[i].apply(self, args);
  }
}

EventEmitter.prototype.emit = function emit(type) {
  var er, handler, len, args, i, events;
  var doError = (type === 'error');

  events = this._events;
  if (events)
    doError = (doError && events.error == null);
  else if (!doError)
    return false;

  // If there is no 'error' event listener then throw.
  if (doError) {
    if (arguments.length > 1)
      er = arguments[1];
    if (er instanceof Error) {
      throw er; // Unhandled 'error' event
    } else {
      // At least give some kind of context to the user
      var err = new Error('Unhandled "error" event. (' + er + ')');
      err.context = er;
      throw err;
    }
    return false;
  }

  handler = events[type];

  if (!handler)
    return false;

  var isFn = typeof handler === 'function';
  len = arguments.length;
  switch (len) {
      // fast cases
    case 1:
      emitNone(handler, isFn, this);
      break;
    case 2:
      emitOne(handler, isFn, this, arguments[1]);
      break;
    case 3:
      emitTwo(handler, isFn, this, arguments[1], arguments[2]);
      break;
    case 4:
      emitThree(handler, isFn, this, arguments[1], arguments[2], arguments[3]);
      break;
      // slower
    default:
      args = new Array(len - 1);
      for (i = 1; i < len; i++)
        args[i - 1] = arguments[i];
      emitMany(handler, isFn, this, args);
  }

  return true;
};

function _addListener(target, type, listener, prepend) {
  var m;
  var events;
  var existing;

  if (typeof listener !== 'function')
    throw new TypeError('"listener" argument must be a function');

  events = target._events;
  if (!events) {
    events = target._events = objectCreate(null);
    target._eventsCount = 0;
  } else {
    // To avoid recursion in the case that type === "newListener"! Before
    // adding it to the listeners, first emit "newListener".
    if (events.newListener) {
      target.emit('newListener', type,
          listener.listener ? listener.listener : listener);

      // Re-assign `events` because a newListener handler could have caused the
      // this._events to be assigned to a new object
      events = target._events;
    }
    existing = events[type];
  }

  if (!existing) {
    // Optimize the case of one listener. Don't need the extra array object.
    existing = events[type] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === 'function') {
      // Adding the second element, need to change to array.
      existing = events[type] =
          prepend ? [listener, existing] : [existing, listener];
    } else {
      // If we've already got an array, just append.
      if (prepend) {
        existing.unshift(listener);
      } else {
        existing.push(listener);
      }
    }

    // Check for listener leak
    if (!existing.warned) {
      m = $getMaxListeners(target);
      if (m && m > 0 && existing.length > m) {
        existing.warned = true;
        var w = new Error('Possible EventEmitter memory leak detected. ' +
            existing.length + ' "' + String(type) + '" listeners ' +
            'added. Use emitter.setMaxListeners() to ' +
            'increase limit.');
        w.name = 'MaxListenersExceededWarning';
        w.emitter = target;
        w.type = type;
        w.count = existing.length;
        if (typeof console === 'object' && console.warn) {
          console.warn('%s: %s', w.name, w.message);
        }
      }
    }
  }

  return target;
}

EventEmitter.prototype.addListener = function addListener(type, listener) {
  return _addListener(this, type, listener, false);
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.prependListener =
    function prependListener(type, listener) {
      return _addListener(this, type, listener, true);
    };

function onceWrapper() {
  if (!this.fired) {
    this.target.removeListener(this.type, this.wrapFn);
    this.fired = true;
    switch (arguments.length) {
      case 0:
        return this.listener.call(this.target);
      case 1:
        return this.listener.call(this.target, arguments[0]);
      case 2:
        return this.listener.call(this.target, arguments[0], arguments[1]);
      case 3:
        return this.listener.call(this.target, arguments[0], arguments[1],
            arguments[2]);
      default:
        var args = new Array(arguments.length);
        for (var i = 0; i < args.length; ++i)
          args[i] = arguments[i];
        this.listener.apply(this.target, args);
    }
  }
}

function _onceWrap(target, type, listener) {
  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };
  var wrapped = bind.call(onceWrapper, state);
  wrapped.listener = listener;
  state.wrapFn = wrapped;
  return wrapped;
}

EventEmitter.prototype.once = function once(type, listener) {
  if (typeof listener !== 'function')
    throw new TypeError('"listener" argument must be a function');
  this.on(type, _onceWrap(this, type, listener));
  return this;
};

EventEmitter.prototype.prependOnceListener =
    function prependOnceListener(type, listener) {
      if (typeof listener !== 'function')
        throw new TypeError('"listener" argument must be a function');
      this.prependListener(type, _onceWrap(this, type, listener));
      return this;
    };

// Emits a 'removeListener' event if and only if the listener was removed.
EventEmitter.prototype.removeListener =
    function removeListener(type, listener) {
      var list, events, position, i, originalListener;

      if (typeof listener !== 'function')
        throw new TypeError('"listener" argument must be a function');

      events = this._events;
      if (!events)
        return this;

      list = events[type];
      if (!list)
        return this;

      if (list === listener || list.listener === listener) {
        if (--this._eventsCount === 0)
          this._events = objectCreate(null);
        else {
          delete events[type];
          if (events.removeListener)
            this.emit('removeListener', type, list.listener || listener);
        }
      } else if (typeof list !== 'function') {
        position = -1;

        for (i = list.length - 1; i >= 0; i--) {
          if (list[i] === listener || list[i].listener === listener) {
            originalListener = list[i].listener;
            position = i;
            break;
          }
        }

        if (position < 0)
          return this;

        if (position === 0)
          list.shift();
        else
          spliceOne(list, position);

        if (list.length === 1)
          events[type] = list[0];

        if (events.removeListener)
          this.emit('removeListener', type, originalListener || listener);
      }

      return this;
    };

EventEmitter.prototype.removeAllListeners =
    function removeAllListeners(type) {
      var listeners, events, i;

      events = this._events;
      if (!events)
        return this;

      // not listening for removeListener, no need to emit
      if (!events.removeListener) {
        if (arguments.length === 0) {
          this._events = objectCreate(null);
          this._eventsCount = 0;
        } else if (events[type]) {
          if (--this._eventsCount === 0)
            this._events = objectCreate(null);
          else
            delete events[type];
        }
        return this;
      }

      // emit removeListener for all listeners on all events
      if (arguments.length === 0) {
        var keys = objectKeys(events);
        var key;
        for (i = 0; i < keys.length; ++i) {
          key = keys[i];
          if (key === 'removeListener') continue;
          this.removeAllListeners(key);
        }
        this.removeAllListeners('removeListener');
        this._events = objectCreate(null);
        this._eventsCount = 0;
        return this;
      }

      listeners = events[type];

      if (typeof listeners === 'function') {
        this.removeListener(type, listeners);
      } else if (listeners) {
        // LIFO order
        for (i = listeners.length - 1; i >= 0; i--) {
          this.removeListener(type, listeners[i]);
        }
      }

      return this;
    };

function _listeners(target, type, unwrap) {
  var events = target._events;

  if (!events)
    return [];

  var evlistener = events[type];
  if (!evlistener)
    return [];

  if (typeof evlistener === 'function')
    return unwrap ? [evlistener.listener || evlistener] : [evlistener];

  return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
}

EventEmitter.prototype.listeners = function listeners(type) {
  return _listeners(this, type, true);
};

EventEmitter.prototype.rawListeners = function rawListeners(type) {
  return _listeners(this, type, false);
};

EventEmitter.listenerCount = function(emitter, type) {
  if (typeof emitter.listenerCount === 'function') {
    return emitter.listenerCount(type);
  } else {
    return listenerCount.call(emitter, type);
  }
};

EventEmitter.prototype.listenerCount = listenerCount;
function listenerCount(type) {
  var events = this._events;

  if (events) {
    var evlistener = events[type];

    if (typeof evlistener === 'function') {
      return 1;
    } else if (evlistener) {
      return evlistener.length;
    }
  }

  return 0;
}

EventEmitter.prototype.eventNames = function eventNames() {
  return this._eventsCount > 0 ? Reflect.ownKeys(this._events) : [];
};

// About 1.5x faster than the two-arg version of Array#splice().
function spliceOne(list, index) {
  for (var i = index, k = i + 1, n = list.length; k < n; i += 1, k += 1)
    list[i] = list[k];
  list.pop();
}

function arrayClone(arr, n) {
  var copy = new Array(n);
  for (var i = 0; i < n; ++i)
    copy[i] = arr[i];
  return copy;
}

function unwrapListeners(arr) {
  var ret = new Array(arr.length);
  for (var i = 0; i < ret.length; ++i) {
    ret[i] = arr[i].listener || arr[i];
  }
  return ret;
}

function objectCreatePolyfill(proto) {
  var F = function() {};
  F.prototype = proto;
  return new F;
}
function objectKeysPolyfill(obj) {
  var keys = [];
  for (var k in obj) if (Object.prototype.hasOwnProperty.call(obj, k)) {
    keys.push(k);
  }
  return k;
}
function functionBindPolyfill(context) {
  var fn = this;
  return function () {
    return fn.apply(context, arguments);
  };
}

},{}]},{},[24]);
